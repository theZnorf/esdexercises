<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>CompositeTag.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (4) (Oct 27, 2015 3:17:09 PM)</a> &gt; <a href="../../index.html" class="el_group">HTMLParser-2.0-SNAPSHOT</a> &gt; <a href="../index.html" class="el_bundle">parser/src/main/java</a> &gt; <a href="index.source.html" class="el_package">org.htmlparser.tags</a> &gt; <span class="el_source">CompositeTag.java</span></div><h1>CompositeTag.java</h1><pre class="source lang-java linenums">// HTMLParser Library - A java-based parser for HTML
// http://htmlparser.org
// Copyright (C) 2006 Somik Raha
//
// Revision Control Information
//
// $URL: https://svn.sourceforge.net/svnroot/htmlparser/trunk/parser/src/main/java/org/htmlparser/tags/CompositeTag.java $
// $Author: derrickoswald $
// $Date: 2006-09-16 10:44:17 -0400 (Sat, 16 Sep 2006) $
// $Revision: 4 $
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the Common Public License; either
// version 1.0 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// Common Public License for more details.
//
// You should have received a copy of the Common Public License
// along with this library; if not, the license is available from
// the Open Source Initiative (OSI) website:
//   http://opensource.org/licenses/cpl1.0.php

package org.htmlparser.tags;

import java.util.Locale;

import org.htmlparser.Node;
import org.htmlparser.NodeFilter;
import org.htmlparser.Text;
import org.htmlparser.Tag;
import org.htmlparser.filters.NodeClassFilter;
import org.htmlparser.nodes.AbstractNode;
import org.htmlparser.nodes.TagNode;
import org.htmlparser.scanners.CompositeTagScanner;
import org.htmlparser.util.NodeList;
import org.htmlparser.util.SimpleNodeIterator;
import org.htmlparser.visitors.NodeVisitor;

/**
 * The base class for tags that have an end tag.
 * Provided extra accessors for the children above and beyond what the basic
 * {@link Tag} provides. Also handles the conversion of it's children for
 * the {@link #toHtml toHtml} method.
 */
public class CompositeTag extends TagNode
{
    /**
     * The tag that causes this tag to finish.
     * May be a virtual tag generated by the scanning logic.
     */
    protected Tag mEndTag;

    /**
     * The default scanner for non-composite tags.
     */
<span class="fc" id="L59">    protected final static CompositeTagScanner mDefaultCompositeScanner = new CompositeTagScanner ();</span>

    /**
     * Create a composite tag.
     */
<span class="fc" id="L64">    public CompositeTag ()</span>
    {
<span class="fc" id="L66">        setThisScanner (mDefaultCompositeScanner);</span>
<span class="fc" id="L67">    }</span>
    
    /**
     * Get an iterator over the children of this node.
     * @return Am iterator over the children of this node.
     */
    public SimpleNodeIterator children ()
    {
        SimpleNodeIterator ret;

<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (null != getChildren ())</span>
<span class="fc" id="L78">            ret = getChildren ().elements ();</span>
        else
<span class="fc" id="L80">            ret = (new NodeList ()).elements ();</span>

<span class="fc" id="L82">        return (ret);</span>
    }

    /**
     * Get the child of this node at the given position.
     * @param index The in the node list of the child.
     * @return The child at that index.
     */
    public Node getChild (int index)
    {
<span class="fc" id="L92">        return (</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">            (null == getChildren ()) ? null :</span>
<span class="fc" id="L94">            getChildren ().elementAt (index));</span>
    }

    /**
     * Get the children as an array of &lt;code&gt;Node&lt;/code&gt; objects.
     * @return The children in an array.
     */
    public Node [] getChildrenAsNodeArray ()
    {
<span class="fc" id="L103">        return (</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">            (null == getChildren ()) ? new Node[0] :</span>
<span class="fc" id="L105">            getChildren ().toNodeArray ());</span>
    }

    /**
     * Remove the child at the position given.
     * @param i The index of the child to remove.
     */
    public void removeChild (int i)
    {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (null != getChildren ())</span>
<span class="nc" id="L115">            getChildren ().remove (i);</span>
<span class="nc" id="L116">    }</span>

    /**
     * Return the child tags as an iterator.
     * Equivalent to calling getChildren ().elements ().
     * @return An iterator over the children.
     */
    public SimpleNodeIterator elements()
    {
<span class="nc" id="L125">        return (</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">            (null == getChildren ()) ? new NodeList ().elements () :</span>
<span class="nc" id="L127">            getChildren ().elements ());</span>
    }

    /**
     * Return the textual contents of this tag and it's children.
     * @return The 'browser' text contents of this tag.
     */
    public String toPlainTextString() {
<span class="fc" id="L135">        StringBuffer stringRepresentation = new StringBuffer();</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (SimpleNodeIterator e=children();e.hasMoreNodes();) {</span>
<span class="fc" id="L137">            stringRepresentation.append(e.nextNode().toPlainTextString());</span>
        }
<span class="fc" id="L139">        return stringRepresentation.toString();</span>
    }

    /**
     * Add the textual contents of the children of this node to the buffer.
     * @param verbatim If &lt;code&gt;true&lt;/code&gt; return as close to the original
     * page text as possible.
     * @param sb The buffer to append to.
     */
    protected void putChildrenInto (StringBuffer sb, boolean verbatim)
    {
        Node node;
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (SimpleNodeIterator e = children (); e.hasMoreNodes ();)</span>
        {
<span class="fc" id="L153">            node = e.nextNode ();</span>
            // eliminate virtual tags
<span class="pc bpc" id="L155" title="3 of 4 branches missed.">            if (!verbatim || !(node.getStartPosition () == node.getEndPosition ()))</span>
<span class="fc" id="L156">                sb.append (node.toHtml ());</span>
        }
<span class="fc" id="L158">    }</span>

    /**
     * Add the textual contents of the end tag of this node to the buffer.
     * @param verbatim If &lt;code&gt;true&lt;/code&gt; return as close to the original
     * page text as possible.
     * @param sb The buffer to append to.
     */
    protected void putEndTagInto (StringBuffer sb, boolean verbatim)
    {
        // eliminate virtual tags
<span class="pc bpc" id="L169" title="3 of 4 branches missed.">        if (!verbatim || !(mEndTag.getStartPosition () == mEndTag.getEndPosition ()))</span>
<span class="fc" id="L170">            sb.append (getEndTag ().toHtml());</span>
<span class="fc" id="L171">    }</span>

    /**
     * Return this tag as HTML code.
     * @param verbatim If &lt;code&gt;true&lt;/code&gt; return as close to the original
     * page text as possible.
     * @return This tag and it's contents (children) and the end tag
     * as HTML code.
     */
    public String toHtml (boolean verbatim)
    {
        StringBuffer ret;
        
<span class="fc" id="L184">        ret = new StringBuffer ();</span>
<span class="fc" id="L185">        ret.append (super.toHtml (verbatim));</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (!isEmptyXmlTag ())</span>
        {
<span class="fc" id="L188">            putChildrenInto (ret, verbatim);</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (null != getEndTag ())</span>
<span class="fc" id="L190">                putEndTagInto (ret, verbatim);</span>
        }
<span class="fc" id="L192">        return (ret.toString ());</span>
    }

    /**
     * Searches all children who for a name attribute. Returns first match.
     * @param name Attribute to match in tag
     * @return Tag Tag matching the name attribute
     */
    public Tag searchByName(String name) {
        Node node;
<span class="fc" id="L202">        Tag tag = null;</span>
<span class="fc" id="L203">        boolean found = false;</span>
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">        for (SimpleNodeIterator e = children();e.hasMoreNodes() &amp;&amp; !found;) {</span>
<span class="fc" id="L205">            node = e.nextNode();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            if (node instanceof Tag)</span>
            {
<span class="fc" id="L208">                tag = (Tag)node;</span>
<span class="fc" id="L209">                String nameAttribute = tag.getAttribute(&quot;NAME&quot;);</span>
<span class="fc bfc" id="L210" title="All 4 branches covered.">                if (nameAttribute!=null &amp;&amp; nameAttribute.equals(name))</span>
<span class="fc" id="L211">                    found=true;</span>
            }
        }
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (found)</span>
<span class="fc" id="L215">            return tag;</span>
        else
<span class="nc" id="L217">            return null;</span>
    }

    /**
     * Searches for all nodes whose text representation contains the search string.
     * Collects all nodes containing the search string into a NodeList.
     * This search is &lt;b&gt;case-insensitive&lt;/b&gt; and the search string and the
     * node text are converted to uppercase using an English locale.
     * For example, if you wish to find any textareas in a form tag containing
     * &quot;hello world&quot;, the code would be:
     * &lt;code&gt;
     * NodeList nodeList = formTag.searchFor(&quot;Hello World&quot;);
     * &lt;/code&gt;
     * @param searchString Search criterion.
     * @return A collection of nodes whose string contents or
     * representation have the &lt;code&gt;searchString&lt;/code&gt; in them.
     */
    public NodeList searchFor (String searchString)
    {
<span class="fc" id="L236">        return (searchFor (searchString, false));</span>
    }

    /**
     * Searches for all nodes whose text representation contains the search string.
     * Collects all nodes containing the search string into a NodeList.
     * For example, if you wish to find any textareas in a form tag containing
     * &quot;hello world&quot;, the code would be:
     * &lt;code&gt;
     * NodeList nodeList = formTag.searchFor(&quot;Hello World&quot;);
     * &lt;/code&gt;
     * @param searchString Search criterion.
     * @param caseSensitive If &lt;code&gt;true&lt;/code&gt; this search should be case
     * sensitive. Otherwise, the search string and the node text are converted
     * to uppercase using an English locale.
     * @return A collection of nodes whose string contents or
     * representation have the &lt;code&gt;searchString&lt;/code&gt; in them.
     */
    public NodeList searchFor (String searchString, boolean caseSensitive)
    {
<span class="fc" id="L256">        return (searchFor (searchString, caseSensitive, Locale.ENGLISH));</span>
    }

    /**
     * Searches for all nodes whose text representation contains the search string.
     * Collects all nodes containing the search string into a NodeList.
     * For example, if you wish to find any textareas in a form tag containing
     * &quot;hello world&quot;, the code would be:
     * &lt;code&gt;
     * NodeList nodeList = formTag.searchFor(&quot;Hello World&quot;);
     * &lt;/code&gt;
     * @param searchString Search criterion.
     * @param caseSensitive If &lt;code&gt;true&lt;/code&gt; this search should be case
     * sensitive. Otherwise, the search string and the node text are converted
     * to uppercase using the locale provided.
     * @param locale The locale for uppercase conversion.
     * @return A collection of nodes whose string contents or
     * representation have the &lt;code&gt;searchString&lt;/code&gt; in them.
     */
    public NodeList searchFor (String searchString, boolean caseSensitive, Locale locale)
    {
        Node node;
        String text;
        NodeList ret;
        
<span class="fc" id="L281">        ret = new NodeList ();</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (!caseSensitive)</span>
<span class="fc" id="L284">            searchString = searchString.toUpperCase (locale);</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        for (SimpleNodeIterator e = children (); e.hasMoreNodes (); )</span>
        {
<span class="fc" id="L287">            node = e.nextNode ();</span>
<span class="fc" id="L288">            text = node.toPlainTextString ();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (!caseSensitive)</span>
<span class="fc" id="L290">                text = text.toUpperCase (locale);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (-1 != text.indexOf (searchString))</span>
<span class="fc" id="L292">                ret.add (node);</span>
        }

<span class="fc" id="L295">        return (ret);</span>
    }

    /**
     * Collect all objects that are of a certain type
     * Note that this will not check for parent types, and will not
     * recurse through child tags
     * @param classType The class to search for.
     * @param recursive If true, recursively search through the children.
     * @return A list of children found.
     */
    public NodeList searchFor (Class classType, boolean recursive)
    {
        NodeList children;
        NodeList ret;

<span class="fc" id="L311">        children = getChildren ();</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">        if (null == children)</span>
<span class="nc" id="L313">            ret = new NodeList ();</span>
        else
<span class="fc" id="L315">            ret = children.extractAllNodesThatMatch (</span>
<span class="fc" id="L316">                new NodeClassFilter (classType), recursive);</span>

<span class="fc" id="L318">        return (ret);</span>
    }

    /**
     * Returns the node number of the first node containing the given text.
     * This can be useful to index into the composite tag and get other children.
     * Text is compared without case sensitivity and conversion to uppercase
     * uses an English locale.
     * @param text The text to search for.
     * @return int The node index in the children list of the node containing
     * the text or -1 if not found.
     * @see #findPositionOf (String, Locale)
     */
    public int findPositionOf (String text)
    {
<span class="nc" id="L333">        return (findPositionOf (text, Locale.ENGLISH));</span>
    }

    /**
     * Returns the node number of the first node containing the given text.
     * This can be useful to index into the composite tag and get other children.
     * Text is compared without case sensitivity and conversion to uppercase
     * uses the supplied locale.
     * @return int The node index in the children list of the node containing
     * the text or -1 if not found.
     * @param locale The locale to use in converting to uppercase.
     * @param text The text to search for.
     */
    public int findPositionOf (String text, Locale locale)
    {
        Node node;
        int loc;
        
<span class="nc" id="L351">        loc = 0;</span>
<span class="nc" id="L352">        text = text.toUpperCase (locale);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        for (SimpleNodeIterator e = children (); e.hasMoreNodes (); )</span>
        {
<span class="nc" id="L355">            node = e.nextNode ();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (-1 != node.toPlainTextString ().toUpperCase (locale).indexOf (text))</span>
<span class="nc" id="L357">                return loc;</span>
<span class="nc" id="L358">            loc++;</span>
        }
<span class="nc" id="L360">        return -1;</span>
    }

    /**
     * Returns the node number of a child node given the node object.
     * This would typically be used in conjuction with digUpStringNode,
     * after which the string node's parent can be used to find the
     * string node's position. Faster than calling findPositionOf(text)
     * again. Note that the position is at a linear level alone - there
     * is no recursion in this method.
     * @param searchNode The child node to find.
     * @return The offset of the child tag or -1 if it was not found.
     */
    public int findPositionOf(Node searchNode) {
        Node node;
<span class="fc" id="L375">        int loc = 0;</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        for (SimpleNodeIterator e=children();e.hasMoreNodes();) {</span>
<span class="fc" id="L377">            node = e.nextNode();</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            if (node==searchNode) {</span>
<span class="fc" id="L379">                return loc;</span>
            }
<span class="fc" id="L381">            loc++;</span>
        }
<span class="nc" id="L383">        return -1;</span>
    }

    /**
     * Get child at given index
     * @param index The index into the child node list.
     * @return Node The child node at the given index or null if none.
     */
    public Node childAt (int index)
    {
<span class="fc" id="L393">        return (</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            (null == getChildren ()) ? null :</span>
<span class="fc" id="L395">            getChildren ().elementAt (index));</span>
    }

    /**
     * Collect this node and its child nodes (if-applicable) into the list parameter,
     * provided the node satisfies the filtering criteria.
     * &lt;p&gt;This mechanism allows powerful filtering code to be written very easily,
     * without bothering about collection of embedded tags separately.
     * e.g. when we try to get all the links on a page, it is not possible to
     * get it at the top-level, as many tags (like form tags), can contain
     * links embedded in them. We could get the links out by checking if the
     * current node is a {@link CompositeTag}, and going through its children.
     * So this method provides a convenient way to do this.&lt;/p&gt;
     * &lt;p&gt;Using collectInto(), programs get a lot shorter. Now, the code to
     * extract all links from a page would look like:
     * &lt;pre&gt;
     * NodeList list = new NodeList();
     * NodeFilter filter = new TagNameFilter (&quot;A&quot;);
     * for (NodeIterator e = parser.elements(); e.hasMoreNodes();)
     *      e.nextNode().collectInto(list, filter);
     * &lt;/pre&gt;
     * Thus, &lt;code&gt;list&lt;/code&gt; will hold all the link nodes, irrespective of how
     * deep the links are embedded.&lt;/p&gt;
     * &lt;p&gt;Another way to accomplish the same objective is:
     * &lt;pre&gt;
     * NodeList list = new NodeList();
     * NodeFilter filter = new TagClassFilter (LinkTag.class);
     * for (NodeIterator e = parser.elements(); e.hasMoreNodes();)
     *      e.nextNode().collectInto(list, filter);
     * &lt;/pre&gt;
     * This is slightly less specific because the LinkTag class may be
     * registered for more than one node name, e.g. &amp;lt;LINK&amp;gt; tags too.&lt;/p&gt;
     * @param list The list to add nodes to.
     * @param filter The filter to apply.
     * @see org.htmlparser.filters
     */
    public void collectInto (NodeList list, NodeFilter filter)
    {
<span class="fc" id="L433">        super.collectInto (list, filter);</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        for (SimpleNodeIterator e = children(); e.hasMoreNodes ();)</span>
<span class="fc" id="L435">            e.nextNode ().collectInto (list, filter);</span>
<span class="pc bpc" id="L436" title="1 of 4 branches missed.">        if ((null != getEndTag ()) &amp;&amp; (this != getEndTag ())) // 2nd guard handles &lt;tag/&gt;</span>
<span class="fc" id="L437">            getEndTag ().collectInto (list, filter);</span>
<span class="fc" id="L438">    }</span>

    /**
     * Return the HTML code for the children of this tag.
     * @return A string with the HTML code for the contents of this tag.
     */
    public String getChildrenHTML() {
<span class="fc" id="L445">        StringBuffer buff = new StringBuffer();</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        for (SimpleNodeIterator e = children();e.hasMoreNodes();) {</span>
<span class="fc" id="L447">            AbstractNode node = (AbstractNode)e.nextNode();</span>
<span class="fc" id="L448">            buff.append(node.toHtml());</span>
        }
<span class="fc" id="L450">        return buff.toString();</span>
    }

    /**
     * Tag visiting code.
     * Invokes &lt;code&gt;accept()&lt;/code&gt; on the start tag and then
     * walks the child list invoking &lt;code&gt;accept()&lt;/code&gt; on each
     * of the children, finishing up with an &lt;code&gt;accept()&lt;/code&gt;
     * call on the end tag. If &lt;code&gt;shouldRecurseSelf()&lt;/code&gt;
     * returns true it then asks the visitor to visit itself.
     * @param visitor The &lt;code&gt;NodeVisitor&lt;/code&gt; object to be signalled
     * for each child and possibly this tag.
     */
    public void accept (NodeVisitor visitor)
    {
        SimpleNodeIterator children;
        Node child;

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (visitor.shouldRecurseSelf ())</span>
<span class="fc" id="L469">            visitor.visitTag (this);</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (visitor.shouldRecurseChildren ())</span>
        {
<span class="fc bfc" id="L472" title="All 2 branches covered.">            if (null != getChildren ())</span>
            {
<span class="fc" id="L474">                children = children ();</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">                while (children.hasMoreNodes ())</span>
                {
<span class="fc" id="L477">                    child = children.nextNode ();</span>
<span class="fc" id="L478">                    child.accept (visitor);</span>
                }
            }
<span class="pc bpc" id="L481" title="2 of 4 branches missed.">            if ((null != getEndTag ()) &amp;&amp; (this != getEndTag ())) // 2nd guard handles &lt;tag/&gt;</span>
<span class="fc" id="L482">                getEndTag ().accept (visitor);</span>
        }
<span class="fc" id="L484">    }</span>

    /**
     * Return the number of child nodes in this tag.
     * @return The child node count.
     */
    public int getChildCount()
    {
        NodeList children;
        
<span class="fc" id="L494">        children = getChildren ();</span>

<span class="fc bfc" id="L496" title="All 2 branches covered.">        return ((null == children) ? 0 : children.size ());</span>
    }

    /**
     * Get the end tag for this tag.
     * For example, if the node is {@.html &lt;LABEL&gt;The label&lt;/LABLE&gt;}, then
     * this method would return the {@.html &lt;/LABLE&gt;} end tag.
     * @return The end tag for this node.
     * &lt;em&gt;Note: If the start and end position of the end tag is the same,
     * then the end tag was injected (it's a virtual end tag).&lt;/em&gt;
     */
    public Tag getEndTag()
    {
<span class="fc" id="L509">        return (mEndTag);</span>
    }

    /**
     * Set the end tag for this tag.
     * @param tag The new end tag for this tag.
     * Note: no checking is perfromed so you can generate bad HTML by setting
     * the end tag with a name not equal to the name of the start tag,
     * i.e. {@.html &lt;LABEL&gt;The label&lt;/TITLE&gt;}
     */
    public void setEndTag (Tag tag)
    {
<span class="fc" id="L521">        mEndTag = tag;</span>
<span class="fc" id="L522">    }</span>

    /**
     * Finds a text node, however embedded it might be, and returns
     * it. The text node will retain links to its parents, so
     * further navigation is possible.
     * @param searchText The text to search for.
     * @return The list of text nodes (recursively) found.
     */
    public Text[] digupStringNode(String searchText) {
<span class="fc" id="L532">        NodeList nodeList = searchFor(searchText);</span>
<span class="fc" id="L533">        NodeList stringNodes = new NodeList();</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">        for (int i=0;i&lt;nodeList.size();i++) {</span>
<span class="fc" id="L535">            Node node = nodeList.elementAt(i);</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (node instanceof Text) {</span>
<span class="fc" id="L537">                stringNodes.add(node);</span>
<span class="fc" id="L538">            } else {</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                if (node instanceof CompositeTag) {</span>
<span class="fc" id="L540">                    CompositeTag ctag = (CompositeTag)node;</span>
<span class="fc" id="L541">                    Text[] nodes = ctag.digupStringNode(searchText);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                    for (int j=0;j&lt;nodes.length;j++)</span>
<span class="fc" id="L543">                        stringNodes.add(nodes[j]);</span>
                }
            }
        }
<span class="fc" id="L547">        Text[] stringNode = new Text[stringNodes.size()];</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        for (int i=0;i&lt;stringNode.length;i++) {</span>
<span class="fc" id="L549">            stringNode[i] = (Text)stringNodes.elementAt(i);</span>
        }
<span class="fc" id="L551">        return stringNode;</span>
    }

    /**
     * Return a string representation of the contents of this tag, it's children and it's end tag suitable for debugging.
     * @return A textual representation of the tag.
     */
    public String toString ()
    {
        StringBuffer ret;
        
<span class="fc" id="L562">        ret = new StringBuffer (1024);</span>
<span class="fc" id="L563">        toString (0, ret);</span>
        
<span class="fc" id="L565">        return (ret.toString ());</span>
    }

    /**
     * Return the text contained in this tag.
     * @return The complete contents of the tag (within the angle brackets).
     */
    public String getText ()
    {
        String ret;
        
<span class="fc" id="L576">        ret = super.toHtml (true); // need TagNode.toHtml(boolean)</span>
<span class="fc" id="L577">        ret = ret.substring (1, ret.length () - 1);</span>
        
<span class="fc" id="L579">        return (ret);</span>
    }

    /**
     * Return the text between the start tag and the end tag.
     * @return The contents of the CompositeTag.
     */
    public String getStringText ()
    {
        String ret;
<span class="nc" id="L589">        int start = getEndPosition ();</span>
<span class="nc" id="L590">        int end = mEndTag.getStartPosition ();</span>
<span class="nc" id="L591">        ret = getPage ().getText (start, end);</span>
        
<span class="nc" id="L593">        return (ret);</span>
    }

    /**
     * Return a string representation of the contents of this tag, it's children and it's end tag suitable for debugging.
     * @param level The indentation level to use.
     * @param buffer The buffer to append to.
     */
    public void toString (int level, StringBuffer buffer)
    {
        Node node;

<span class="pc bpc" id="L605" title="1 of 2 branches missed.">        for (int i = 0; i &lt; level; i++)</span>
<span class="nc" id="L606">            buffer.append (&quot;  &quot;);</span>
<span class="fc" id="L607">        buffer.append (super.toString ());</span>
<span class="fc" id="L608">        buffer.append (System.getProperty (&quot;line.separator&quot;));</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">        for (SimpleNodeIterator e = children (); e.hasMoreNodes ();)</span>
        {
<span class="nc" id="L611">            node = e.nextNode ();</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (node instanceof CompositeTag)</span>
<span class="nc" id="L613">                ((CompositeTag)node).toString (level + 1, buffer);</span>
            else
            {
<span class="nc bnc" id="L616" title="All 2 branches missed.">                for (int i = 0; i &lt;= level; i++)</span>
<span class="nc" id="L617">                    buffer.append (&quot;  &quot;);</span>
<span class="nc" id="L618">                buffer.append (node);</span>
<span class="nc" id="L619">                buffer.append (System.getProperty (&quot;line.separator&quot;));</span>
            }
        }
        
<span class="pc bpc" id="L623" title="2 of 4 branches missed.">        if ((null != getEndTag ()) &amp;&amp; (this != getEndTag ())) // 2nd guard handles &lt;tag/&gt;</span>
            // eliminate virtual tags
//            if (!(getEndTag ().getStartPosition () == getEndTag ().getEndPosition ()))
            {
<span class="nc bnc" id="L627" title="All 2 branches missed.">                for (int i = 0; i &lt;= level; i++)</span>
<span class="nc" id="L628">                    buffer.append (&quot;  &quot;);</span>
<span class="nc" id="L629">                buffer.append (getEndTag ().toString ());</span>
<span class="nc" id="L630">                buffer.append (System.getProperty (&quot;line.separator&quot;));</span>
            }
<span class="fc" id="L632">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (4) (Oct 27, 2015 3:17:09 PM)</div></body></html>