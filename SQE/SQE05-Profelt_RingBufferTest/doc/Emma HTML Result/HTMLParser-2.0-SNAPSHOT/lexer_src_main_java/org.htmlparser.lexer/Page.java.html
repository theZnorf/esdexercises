<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Page.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (4) (Oct 27, 2015 3:17:09 PM)</a> &gt; <a href="../../index.html" class="el_group">HTMLParser-2.0-SNAPSHOT</a> &gt; <a href="../index.html" class="el_bundle">lexer/src/main/java</a> &gt; <a href="index.source.html" class="el_package">org.htmlparser.lexer</a> &gt; <span class="el_source">Page.java</span></div><h1>Page.java</h1><pre class="source lang-java linenums">// HTMLParser Library - A java-based parser for HTML
// http://htmlparser.org
// Copyright (C) 2006 Derrick Oswald
//
// Revision Control Information
//
// $URL: https://svn.sourceforge.net/svnroot/htmlparser/trunk/lexer/src/main/java/org/htmlparser/lexer/Page.java $
// $Author: derrickoswald $
// $Date: 2006-09-16 10:44:17 -0400 (Sat, 16 Sep 2006) $
// $Revision: 4 $
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the Common Public License; either
// version 1.0 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// Common Public License for more details.
//
// You should have received a copy of the Common Public License
// along with this library; if not, the license is available from
// the Open Source Initiative (OSI) website:
//   http://opensource.org/licenses/cpl1.0.php

package org.htmlparser.lexer;

import java.io.InputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.net.UnknownHostException;
import java.util.zip.GZIPInputStream;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;

import org.htmlparser.http.ConnectionManager;
import org.htmlparser.util.ParserException;

/**
 * Represents the contents of an HTML page.
 * Contains the source of characters and an index of positions of line
 * separators (actually the first character position on the next line).
 */
public class Page
    implements
        Serializable
{
    /**
     * The default charset.
     * This should be &lt;code&gt;{@value}&lt;/code&gt;,
     * see RFC 2616 (http://www.ietf.org/rfc/rfc2616.txt?number=2616)
     * section 3.7.1
     * &lt;p&gt;Another alias is &quot;8859_1&quot;.
     */
    public static final String DEFAULT_CHARSET = &quot;ISO-8859-1&quot;;

    /**
     * The default content type.
     * In the absence of alternate information, assume html content ({@value}).
     */
    public static final String DEFAULT_CONTENT_TYPE = &quot;text/html&quot;;

    /**
     * Character value when the page is exhausted.
     * Has a value of {@value}.
     */
    public static final char EOF = (char)Source.EOF;

    /**
     * The URL this page is coming from.
     * Cached value of &lt;code&gt;getConnection().toExternalForm()&lt;/code&gt; or
     * &lt;code&gt;setUrl()&lt;/code&gt;.
     */
    protected String mUrl;

    /**
     * The base URL for this page.
     */
    protected String mBaseUrl;

    /**
     * The source of characters.
     */
    protected Source mSource;

    /**
     * Character positions of the first character in each line.
     */
    protected PageIndex mIndex;

    /**
     * The connection this page is coming from or &lt;code&gt;null&lt;/code&gt;.
     */
    protected transient URLConnection mConnection;

    /**
     * Connection control (proxy, cookies, authorization).
     */
<span class="fc" id="L107">    protected static ConnectionManager mConnectionManager =</span>
<span class="fc" id="L108">        new ConnectionManager ();</span>

    /**
     * Construct an empty page.
     */
    public Page ()
    {
<span class="fc" id="L115">        this (&quot;&quot;);</span>
<span class="fc" id="L116">    }</span>

    /**
     * Construct a page reading from a URL connection.
     * @param connection A fully conditioned connection. The connect()
     * method will be called so it need not be connected yet.
     * @exception ParserException An exception object wrapping a number of
     * possible error conditions, some of which are outlined below.
     * &lt;li&gt;IOException If an i/o exception occurs creating the
     * source.&lt;/li&gt;
     * &lt;li&gt;UnsupportedEncodingException if the character set specified in the
     * HTTP header is not supported.&lt;/li&gt;
     */
<span class="fc" id="L129">    public Page (URLConnection connection) throws ParserException</span>
    {
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (null == connection)</span>
<span class="fc" id="L132">            throw new IllegalArgumentException (&quot;connection cannot be null&quot;);</span>
<span class="fc" id="L133">        setConnection (connection);</span>
<span class="fc" id="L134">        mBaseUrl = null;</span>
<span class="fc" id="L135">    }</span>

    /**
     * Construct a page from a stream encoded with the given charset.
     * @param stream The source of bytes.
     * @param charset The encoding used.
     * If null, defaults to the &lt;code&gt;DEFAULT_CHARSET&lt;/code&gt;.
     * @exception UnsupportedEncodingException If the given charset
     * is not supported.
     */
<span class="nc" id="L145">    public Page (InputStream stream, String charset)</span>
        throws
            UnsupportedEncodingException
    {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (null == stream)</span>
<span class="nc" id="L150">            throw new IllegalArgumentException (&quot;stream cannot be null&quot;);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (null == charset)</span>
<span class="nc" id="L152">            charset = DEFAULT_CHARSET;</span>
<span class="nc" id="L153">        mSource = new InputStreamSource (stream, charset);</span>
<span class="nc" id="L154">        mIndex = new PageIndex (this);</span>
<span class="nc" id="L155">        mConnection = null;</span>
<span class="nc" id="L156">        mUrl = null;</span>
<span class="nc" id="L157">        mBaseUrl = null;</span>
<span class="nc" id="L158">    }</span>

    /**
     * Construct a page from the given string.
     * @param text The HTML text.
     * @param charset &lt;em&gt;Optional&lt;/em&gt;. The character set encoding that will
     * be reported by {@link #getEncoding}. If charset is &lt;code&gt;null&lt;/code&gt;
     * the default character set is used.
     */
<span class="fc" id="L167">    public Page (String text, String charset)</span>
    {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (null == text)</span>
<span class="fc" id="L170">            throw new IllegalArgumentException (&quot;text cannot be null&quot;);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (null == charset)</span>
<span class="fc" id="L172">            charset = DEFAULT_CHARSET;</span>
<span class="fc" id="L173">        mSource = new StringSource (text, charset);</span>
<span class="fc" id="L174">        mIndex = new PageIndex (this);</span>
<span class="fc" id="L175">        mConnection = null;</span>
<span class="fc" id="L176">        mUrl = null;</span>
<span class="fc" id="L177">        mBaseUrl = null;</span>
<span class="fc" id="L178">    }</span>

    /**
     * Construct a page from the given string.
     * The page will report that it is using an encoding of
     * {@link #DEFAULT_CHARSET}.
     * @param text The HTML text.
     */
    public Page (String text)
    {
<span class="fc" id="L188">        this (text, null);</span>
<span class="fc" id="L189">    }</span>

    /**
     * Construct a page from a source.
     * @param source The source of characters.
     */
<span class="nc" id="L195">    public Page (Source source)</span>
    {
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (null == source)</span>
<span class="nc" id="L198">            throw new IllegalArgumentException (&quot;source cannot be null&quot;);</span>
<span class="nc" id="L199">        mSource = source;</span>
<span class="nc" id="L200">        mIndex = new PageIndex (this);</span>
<span class="nc" id="L201">        mConnection = null;</span>
<span class="nc" id="L202">        mUrl = null;</span>
<span class="nc" id="L203">        mBaseUrl = null;</span>
<span class="nc" id="L204">    }</span>

    //
    // static methods
    //

    /**
     * Get the connection manager all Parsers use.
     * @return The connection manager.
     */
    public static ConnectionManager getConnectionManager ()
    {
<span class="fc" id="L216">        return (mConnectionManager);</span>
    }

    /**
     * Set the connection manager to use.
     * @param manager The new connection manager.
     */
    public static void setConnectionManager (ConnectionManager manager)
    {
<span class="nc" id="L225">        mConnectionManager = manager;</span>
<span class="nc" id="L226">    }</span>

    /**
     * Get a CharacterSet name corresponding to a charset parameter.
     * @param content A text line of the form:
     * &lt;pre&gt;
     * text/html; charset=Shift_JIS
     * &lt;/pre&gt;
     * which is applicable both to the HTTP header field Content-Type and
     * the meta tag http-equiv=&quot;Content-Type&quot;.
     * Note this method also handles non-compliant quoted charset directives
     * such as:
     * &lt;pre&gt;
     * text/html; charset=&quot;UTF-8&quot;
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     * text/html; charset='UTF-8'
     * &lt;/pre&gt;
     * @return The character set name to use when reading the input stream.
     * For JDKs that have the Charset class this is qualified by passing
     * the name to findCharset() to render it into canonical form.
     * If the charset parameter is not found in the given string, the default
     * character set is returned.
     * @see #findCharset
     * @see #DEFAULT_CHARSET
     */
    public String getCharset (String content)
    {
<span class="fc" id="L255">        final String CHARSET_STRING = &quot;charset&quot;;</span>
        int index;
        String ret;

<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (null == mSource)</span>
<span class="fc" id="L260">            ret = DEFAULT_CHARSET;</span>
        else
            // use existing (possibly supplied) character set:
            // bug #1322686 when illegal charset specified
<span class="fc" id="L264">            ret = mSource.getEncoding ();</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (null != content)</span>
        {
<span class="fc" id="L267">            index = content.indexOf (CHARSET_STRING);</span>

<span class="fc bfc" id="L269" title="All 2 branches covered.">            if (index != -1)</span>
            {
<span class="fc" id="L271">                content = content.substring (index +</span>
<span class="fc" id="L272">                    CHARSET_STRING.length ()).trim ();</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">                if (content.startsWith (&quot;=&quot;))</span>
                {
<span class="fc" id="L275">                    content = content.substring (1).trim ();</span>
<span class="fc" id="L276">                    index = content.indexOf (&quot;;&quot;);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                    if (index != -1)</span>
<span class="nc" id="L278">                        content = content.substring (0, index);</span>

                    //remove any double quotes from around charset string
<span class="pc bpc" id="L281" title="3 of 4 branches missed.">                    if (content.startsWith (&quot;\&quot;&quot;) &amp;&amp; content.endsWith (&quot;\&quot;&quot;)</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                        &amp;&amp; (1 &lt; content.length ()))</span>
<span class="nc" id="L283">                        content = content.substring (1, content.length () - 1);</span>

                    //remove any single quote from around charset string
<span class="pc bpc" id="L286" title="3 of 4 branches missed.">                    if (content.startsWith (&quot;'&quot;) &amp;&amp; content.endsWith (&quot;'&quot;)</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                        &amp;&amp; (1 &lt; content.length ()))</span>
<span class="nc" id="L288">                        content = content.substring (1, content.length () - 1);</span>

<span class="fc" id="L290">                    ret = findCharset (content, ret);</span>

                    // Charset names are not case-sensitive;
                    // that is, case is always ignored when comparing
                    // charset names.
//                    if (!ret.equalsIgnoreCase (content))
//                    {
//                        System.out.println (
//                            &quot;detected charset \&quot;&quot;
//                            + content
//                            + &quot;\&quot;, using \&quot;&quot;
//                            + ret
//                            + &quot;\&quot;&quot;);
//                    }
                }
            }
        }

<span class="fc" id="L308">        return (ret);</span>
    }

    /**
     * Lookup a character set name.
     * &lt;em&gt;Vacuous for JVM's without &lt;code&gt;java.nio.charset&lt;/code&gt;.&lt;/em&gt;
     * This uses reflection so the code will still run under prior JDK's but
     * in that case the default is always returned.
     * @param name The name to look up. One of the aliases for a character set.
     * @param fallback The name to return if the lookup fails.
     * @return The character set name.
     */
    public static String findCharset (String name, String fallback)
    {
        String ret;

        try
        {
            Class cls;
            Method method;
            Object object;

<span class="fc" id="L330">            cls = Class.forName (&quot;java.nio.charset.Charset&quot;);</span>
<span class="fc" id="L331">            method = cls.getMethod (&quot;forName&quot;, new Class[] { String.class });</span>
<span class="fc" id="L332">            object = method.invoke (null, new Object[] { name });</span>
<span class="fc" id="L333">            method = cls.getMethod (&quot;name&quot;, new Class[] { });</span>
<span class="fc" id="L334">            object = method.invoke (object, new Object[] { });</span>
<span class="fc" id="L335">            ret = (String)object;</span>
<span class="fc" id="L336">        }</span>
<span class="nc" id="L337">        catch (ClassNotFoundException cnfe)</span>
        {
            // for reflection exceptions, assume the name is correct
<span class="nc" id="L340">            ret = name;</span>
        }
<span class="nc" id="L342">        catch (NoSuchMethodException nsme)</span>
        {
            // for reflection exceptions, assume the name is correct
<span class="nc" id="L345">            ret = name;</span>
        }
<span class="nc" id="L347">        catch (IllegalAccessException ia)</span>
        {
            // for reflection exceptions, assume the name is correct
<span class="nc" id="L350">            ret = name;</span>
        }
<span class="nc" id="L352">        catch (InvocationTargetException ita)</span>
        {
            // java.nio.charset.IllegalCharsetNameException
            // and java.nio.charset.UnsupportedCharsetException
            // return the default
<span class="nc" id="L357">            ret = fallback;</span>
<span class="nc" id="L358">            System.out.println (</span>
<span class="nc" id="L359">                &quot;unable to determine cannonical charset name for &quot;</span>
<span class="nc" id="L360">                + name</span>
<span class="nc" id="L361">                + &quot; - using &quot;</span>
<span class="nc" id="L362">                + fallback);</span>
        }

<span class="fc" id="L365">        return (ret);</span>
    }

    //
    // Serialization support
    //

    /**
     * Serialize the page.
     * There are two modes to serializing a page based on the connected state.
     * If connected, the URL and the current offset is saved, while if
     * disconnected, the underling source is saved.
     * @param out The object stream to store this object in.
     * @exception IOException If there is a serialization problem.
     */
    private void writeObject (ObjectOutputStream out)
        throws
            IOException
    {
        String href;
        Source source;
        PageIndex index;

        // two cases, reading from a URL and not
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (null != getConnection ())</span>
        {
<span class="nc" id="L391">            out.writeBoolean (true);</span>
<span class="nc" id="L392">            out.writeInt (mSource.offset ()); // need to preread this much</span>
<span class="nc" id="L393">            href = getUrl ();</span>
<span class="nc" id="L394">            out.writeObject (href);</span>
<span class="nc" id="L395">            setUrl (getConnection ().getURL ().toExternalForm ());</span>
<span class="nc" id="L396">            source = getSource ();</span>
<span class="nc" id="L397">            mSource = null; // don't serialize the source if we can avoid it</span>
<span class="nc" id="L398">            index = mIndex;</span>
<span class="nc" id="L399">            mIndex = null; // will get recreated; valid for the new page anyway?</span>
<span class="nc" id="L400">            out.defaultWriteObject ();</span>
<span class="nc" id="L401">            mSource = source;</span>
<span class="nc" id="L402">            mIndex = index;</span>
<span class="nc" id="L403">        }</span>
        else
        {
<span class="fc" id="L406">            out.writeBoolean (false);</span>
<span class="fc" id="L407">            href = getUrl ();</span>
<span class="fc" id="L408">            out.writeObject (href);</span>
<span class="fc" id="L409">            setUrl (null); // don't try and read a bogus URL</span>
<span class="fc" id="L410">            out.defaultWriteObject ();</span>
<span class="fc" id="L411">            setUrl (href);</span>
        }
<span class="fc" id="L413">    }</span>

    /**
     * Deserialize the page.
     * For details see &lt;code&gt;writeObject()&lt;/code&gt;.
     * @param in The object stream to decode.
     * @exception IOException If there is a deserialization problem with
     * the stream.
     * @exception ClassNotFoundException If the deserialized class can't be
     * located with the current classpath and class loader.
     */
    private void readObject (ObjectInputStream in)
        throws
            IOException,
            ClassNotFoundException
    {
        boolean fromurl;
        int offset;
        String href;
        URL url;
        Cursor cursor;

<span class="fc" id="L435">        fromurl = in.readBoolean ();</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (fromurl)</span>
        {
<span class="nc" id="L438">            offset = in.readInt ();</span>
<span class="nc" id="L439">            href = (String)in.readObject ();</span>
<span class="nc" id="L440">            in.defaultReadObject ();</span>
            // open the URL
<span class="nc bnc" id="L442" title="All 2 branches missed.">            if (null != getUrl ())</span>
            {
<span class="nc" id="L444">                url = new URL (getUrl ());</span>
                try
                {
<span class="nc" id="L447">                    setConnection (url.openConnection ());</span>
<span class="nc" id="L448">                }</span>
<span class="nc" id="L449">                catch (ParserException pe)</span>
                {
<span class="nc" id="L451">                    throw new IOException (pe.getMessage ());</span>
                }
            }
<span class="nc" id="L454">            cursor = new Cursor (this, 0);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            for (int i = 0; i &lt; offset; i++)</span>
                try
                {
<span class="nc" id="L458">                    getCharacter (cursor);</span>
<span class="nc" id="L459">                }</span>
<span class="nc" id="L460">                catch (ParserException pe)</span>
                {
<span class="nc" id="L462">                    throw new IOException (pe.getMessage ());</span>
                }
<span class="nc" id="L464">            setUrl (href);</span>
<span class="nc" id="L465">        }</span>
        else
        {
<span class="fc" id="L468">            href = (String)in.readObject ();</span>
<span class="fc" id="L469">            in.defaultReadObject ();</span>
<span class="fc" id="L470">            setUrl (href);</span>
        }
<span class="fc" id="L472">    }</span>

    /**
     * Reset the page by resetting the source of characters.
     */
    public void reset ()
    {
<span class="fc" id="L479">        getSource ().reset ();</span>
<span class="fc" id="L480">        mIndex = new PageIndex (this); // todo: is this really necessary?</span>
<span class="fc" id="L481">    }</span>

    /**
     * Close the page by destroying the source of characters.
     * @exception IOException If destroying the source encounters an error.
     */
    public void close () throws IOException
    {
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        if (null != getSource ())</span>
<span class="fc" id="L490">            getSource ().destroy ();</span>
<span class="fc" id="L491">    }</span>

    /**
     * Clean up this page, releasing resources.
     * Calls &lt;code&gt;close()&lt;/code&gt;.
     * @exception Throwable if &lt;code&gt;close()&lt;/code&gt; throws an
     * &lt;code&gt;IOException&lt;/code&gt;.
     */
    protected void finalize ()
        throws
            Throwable
    {
<span class="fc" id="L503">        close ();</span>
<span class="fc" id="L504">    }</span>

    /**
     * Get the connection, if any.
     * @return The connection object for this page, or null if this page
     * is built from a stream or a string.
     */
    public URLConnection getConnection ()
    {
<span class="fc" id="L513">        return (mConnection);</span>
    }

    /**
     * Set the URLConnection to be used by this page.
     * Starts reading from the given connection.
     * This also resets the current url.
     * @param connection The connection to use.
     * It will be connected by this method.
     * @exception ParserException If the &lt;code&gt;connect()&lt;/code&gt; method fails,
     * or an I/O error occurs opening the input stream or the character set
     * designated in the HTTP header is unsupported.
     */
    public void setConnection (URLConnection connection)
        throws
            ParserException
    {
        Stream stream;
        String type;
        String charset;
        String contentEncoding;

<span class="fc" id="L535">        mConnection = connection;</span>
        try
        {
<span class="fc" id="L538">            getConnection ().connect ();</span>
<span class="fc" id="L539">        }</span>
<span class="fc" id="L540">        catch (UnknownHostException uhe)</span>
        {
<span class="fc" id="L542">            throw new ParserException (&quot;Connect to &quot;</span>
<span class="fc" id="L543">                + mConnection.getURL ().toExternalForm () + &quot; failed.&quot;, uhe);</span>
        }
<span class="nc" id="L545">        catch (IOException ioe)</span>
        {
<span class="nc" id="L547">            throw new ParserException (&quot;Exception connecting to &quot;</span>
<span class="nc" id="L548">                + mConnection.getURL ().toExternalForm ()</span>
<span class="nc" id="L549">                + &quot; (&quot; + ioe.getMessage () + &quot;).&quot;, ioe);</span>
        }
<span class="fc" id="L551">        type = getContentType ();</span>
<span class="fc" id="L552">        charset = getCharset (type);</span>
        try
        {
<span class="fc" id="L555">            contentEncoding = connection.getContentEncoding();</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">            if ((null != contentEncoding)</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                &amp;&amp; (-1 != contentEncoding.indexOf (&quot;gzip&quot;)))</span>
            {
<span class="nc" id="L559">                stream = new Stream (new GZIPInputStream (</span>
<span class="nc" id="L560">                    getConnection ().getInputStream ()));</span>
<span class="nc" id="L561">            }</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            else if ((null != contentEncoding)</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                &amp;&amp; (-1 != contentEncoding.indexOf (&quot;deflate&quot;)))</span>
            {
<span class="nc" id="L565">                stream = new Stream (new InflaterInputStream (</span>
<span class="nc" id="L566">                    getConnection ().getInputStream (), new Inflater (true)));</span>
<span class="nc" id="L567">            }</span>
            else
            {
<span class="fc" id="L570">                stream = new Stream (getConnection ().getInputStream ());</span>
            }

            try
            {
<span class="fc" id="L575">                mSource = new InputStreamSource (stream, charset);</span>
<span class="fc" id="L576">            }</span>
<span class="nc" id="L577">            catch (UnsupportedEncodingException uee)</span>
            {
//                StringBuffer msg;
//
//                msg = new StringBuffer (1024);
//                msg.append (getConnection ().getURL ().toExternalForm ());
//                msg.append (&quot; has an encoding (&quot;);
//                msg.append (charset);
//                msg.append (&quot;) which is not supported, using &quot;);
//                msg.append (DEFAULT_CHARSET);
//                System.out.println (msg.toString ());
<span class="nc" id="L588">                charset = DEFAULT_CHARSET;</span>
<span class="nc" id="L589">                mSource = new InputStreamSource (stream, charset);</span>
            }
<span class="nc" id="L591">        }</span>
<span class="nc" id="L592">        catch (IOException ioe)</span>
        {
<span class="nc" id="L594">            throw new ParserException (&quot;Exception getting input stream from &quot;</span>
<span class="nc" id="L595">                + mConnection.getURL ().toExternalForm ()</span>
<span class="nc" id="L596">                + &quot; (&quot; + ioe.getMessage () + &quot;).&quot;, ioe);</span>
        }
<span class="fc" id="L598">        mUrl = connection.getURL ().toExternalForm ();</span>
<span class="fc" id="L599">        mIndex = new PageIndex (this);</span>
<span class="fc" id="L600">    }</span>

    /**
     * Get the URL for this page.
     * This is only available if the page has a connection
     * (&lt;code&gt;getConnection()&lt;/code&gt; returns non-null), or the document base has
     * been set via a call to &lt;code&gt;setUrl()&lt;/code&gt;.
     * @return The url for the connection, or &lt;code&gt;null&lt;/code&gt; if there is
     * no conenction or the document base has not been set.
     */
    public String getUrl ()
    {
<span class="fc" id="L612">        return (mUrl);</span>
    }

    /**
     * Set the URL for this page.
     * This doesn't affect the contents of the page, just the interpretation
     * of relative links from this point forward.
     * @param url The new URL.
     */
    public void setUrl (String url)
    {
<span class="fc" id="L623">        mUrl = url;</span>
<span class="fc" id="L624">    }</span>

    /**
     * Gets the baseUrl.
     * @return The base URL for this page, or &lt;code&gt;null&lt;/code&gt; if not set.
     */
    public String getBaseUrl ()
    {
<span class="fc" id="L632">        return (mBaseUrl);</span>
    }

    /**
     * Sets the baseUrl.
     * @param url The base url for this page.
     */
    public void setBaseUrl (String url)
    {
<span class="fc" id="L641">        mBaseUrl = url;</span>
<span class="fc" id="L642">    }</span>

    /**
     * Get the source this page is reading from.
     * @return The current source.
     */
    public Source getSource ()
    {
<span class="fc" id="L650">        return (mSource);</span>
    }

    /**
     * Try and extract the content type from the HTTP header.
     * @return The content type.
     */
    public String getContentType ()
    {
        URLConnection connection;
        String content;
        String ret;

<span class="fc" id="L663">        ret = DEFAULT_CONTENT_TYPE;</span>
<span class="fc" id="L664">        connection = getConnection ();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (null != connection)</span>
        {
            // can't use connection#getContentType
            // see Bug #1467712 Page#getCharset never works
<span class="fc" id="L669">            content = connection.getHeaderField (&quot;Content-Type&quot;);</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">            if (null != content)</span>
<span class="fc" id="L671">                ret = content;</span>
        }

<span class="fc" id="L674">        return (ret);</span>
    }

    /**
     * Read the character at the given cursor position.
     * The cursor position can be only behind or equal to the
     * current source position.
     * Returns end of lines (EOL) as \n, by converting \r and \r\n to \n,
     * and updates the end-of-line index accordingly.
     * Advances the cursor position by one (or two in the \r\n case).
     * @param cursor The position to read at.
     * @return The character at that position, and modifies the cursor to
     * prepare for the next read. If the source is exhausted a zero is returned.
     * @exception ParserException If an IOException on the underlying source
     * occurs, or an attempt is made to read characters in the future (the
     * cursor position is ahead of the underlying stream)
     */
    public char getCharacter (Cursor cursor)
        throws
            ParserException
    {
        int i;
        int offset;
        char ret;

<span class="fc" id="L699">        i = cursor.getPosition ();</span>
<span class="fc" id="L700">        offset = mSource.offset ();</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">        if (offset == i)</span>
            try
            {
<span class="fc" id="L704">                i = mSource.read ();</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">                if (Source.EOF == i)</span>
<span class="fc" id="L706">                    ret = EOF;</span>
                else
                {
<span class="fc" id="L709">                    ret = (char)i;</span>
<span class="fc" id="L710">                    cursor.advance ();</span>
                }
<span class="fc" id="L712">            }</span>
<span class="nc" id="L713">            catch (IOException ioe)</span>
            {
<span class="nc" id="L715">                throw new ParserException (</span>
<span class="nc" id="L716">                    &quot;problem reading a character at position &quot;</span>
<span class="nc" id="L717">                    + cursor.getPosition (), ioe);</span>
            }
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">        else if (offset &gt; i)</span>
        {
            // historic read
            try
            {
<span class="fc" id="L724">                ret = mSource.getCharacter (i);</span>
<span class="fc" id="L725">            }</span>
<span class="nc" id="L726">            catch (IOException ioe)</span>
            {
<span class="nc" id="L728">                throw new ParserException (</span>
<span class="nc" id="L729">                    &quot;can't read a character at position &quot;</span>
<span class="nc" id="L730">                    + i, ioe);</span>
            }
<span class="fc" id="L732">            cursor.advance ();</span>
<span class="fc" id="L733">        }</span>
        else
            // hmmm, we could skip ahead, but then what about the EOL index
<span class="nc" id="L736">            throw new ParserException (</span>
<span class="nc" id="L737">                &quot;attempt to read future characters from source &quot;</span>
<span class="nc" id="L738">                + i + &quot; &gt; &quot; + mSource.offset ());</span>

        // handle \r
<span class="fc bfc" id="L741" title="All 2 branches covered.">        if ('\r' == ret)</span>
        {   // switch to single character EOL
<span class="fc" id="L743">            ret = '\n';</span>

            // check for a \n in the next position
<span class="fc bfc" id="L746" title="All 2 branches covered.">            if (mSource.offset () == cursor.getPosition ())</span>
                try
                {
<span class="fc" id="L749">                    i = mSource.read ();</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                    if (Source.EOF == i)</span>
                    {
                        // do nothing
                    }
<span class="fc bfc" id="L754" title="All 2 branches covered.">                    else if ('\n' == (char)i)</span>
<span class="fc" id="L755">                        cursor.advance ();</span>
                    else
                        try
                        {
<span class="fc" id="L759">                            mSource.unread ();</span>
<span class="fc" id="L760">                        }</span>
<span class="nc" id="L761">                        catch (IOException ioe)</span>
                        {
<span class="nc" id="L763">                            throw new ParserException (</span>
<span class="nc" id="L764">                                &quot;can't unread a character at position &quot;</span>
<span class="nc" id="L765">                                + cursor.getPosition (), ioe);</span>
                        }
                }
<span class="nc" id="L768">                catch (IOException ioe)</span>
                {
<span class="nc" id="L770">                    throw new ParserException (</span>
<span class="nc" id="L771">                        &quot;problem reading a character at position &quot;</span>
<span class="nc" id="L772">                        + cursor.getPosition (), ioe);</span>
                }
            else
                try
                {
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">                    if ('\n' == mSource.getCharacter (cursor.getPosition ()))</span>
<span class="fc" id="L778">                        cursor.advance ();</span>
<span class="fc" id="L779">                }</span>
<span class="nc" id="L780">                catch (IOException ioe)</span>
                {
<span class="nc" id="L782">                    throw new ParserException (</span>
<span class="nc" id="L783">                        &quot;can't read a character at position &quot;</span>
<span class="nc" id="L784">                        + cursor.getPosition (), ioe);</span>
                }
        }
<span class="fc bfc" id="L787" title="All 2 branches covered.">        if ('\n' == ret)</span>
            // update the EOL index in any case
<span class="fc" id="L789">            mIndex.add (cursor);</span>

<span class="fc" id="L791">        return (ret);</span>
    }

    /**
     * Return a character.
     * Handles end of lines (EOL) specially, retreating the cursor twice for
     * the '\r\n' case.
     * The cursor position is moved back by one (or two in the \r\n case).
     * @param cursor The position to 'unread' at.
     * @exception ParserException If an IOException on the underlying source
     * occurs.
     */
    public void ungetCharacter (Cursor cursor)
        throws
            ParserException
    {
        int i;
        char ch;

<span class="fc" id="L810">        cursor.retreat ();</span>
<span class="fc" id="L811">        i = cursor.getPosition ();</span>
        try
        {
<span class="fc" id="L814">            ch = mSource.getCharacter (i);</span>
<span class="fc bfc" id="L815" title="All 4 branches covered.">            if (('\n' == ch) &amp;&amp; (0 != i))</span>
            {
<span class="fc" id="L817">                ch = mSource.getCharacter (i - 1);</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                if ('\r' == ch)</span>
<span class="fc" id="L819">                    cursor.retreat ();</span>
            }
<span class="fc" id="L821">        }</span>
<span class="nc" id="L822">        catch (IOException ioe)</span>
        {
<span class="nc" id="L824">            throw new ParserException (</span>
<span class="nc" id="L825">                &quot;can't read a character at position &quot;</span>
<span class="nc" id="L826">                + cursor.getPosition (), ioe);</span>
        }
<span class="fc" id="L828">    }</span>

    /**
     * Get the current encoding being used.
     * @return The encoding used to convert characters.
     */
    public String getEncoding ()
    {
<span class="nc" id="L836">        return (getSource ().getEncoding ());</span>
    }

    /**
     * Begins reading from the source with the given character set.
     * If the current encoding is the same as the requested encoding,
     * this method is a no-op. Otherwise any subsequent characters read from
     * this page will have been decoded using the given character set.&lt;p&gt;
     * Some magic happens here to obtain this result if characters have already
     * been consumed from this page.
     * Since a Reader cannot be dynamically altered to use a different character
     * set, the underlying stream is reset, a new Source is constructed
     * and a comparison made of the characters read so far with the newly
     * read characters up to the current position.
     * If a difference is encountered, or some other problem occurs,
     * an exception is thrown.
     * @param character_set The character set to use to convert bytes into
     * characters.
     * @exception ParserException If a character mismatch occurs between
     * characters already provided and those that would have been returned
     * had the new character set been in effect from the beginning. An
     * exception is also thrown if the underlying stream won't put up with
     * these shenanigans.
     */
    public void setEncoding (String character_set)
        throws
            ParserException
    {
<span class="fc" id="L864">        getSource ().setEncoding (character_set);</span>
<span class="fc" id="L865">    }</span>

    /**
     * Build a URL from the link and base provided using non-strict rules.
     * @param link The (relative) URI.
     * @param base The base URL of the page, either from the &amp;lt;BASE&amp;gt; tag
     * or, if none, the URL the page is being fetched from.
     * @return An absolute URL.
     * @exception MalformedURLException If creating the URL fails.
     * @see #constructUrl(String, String, boolean)
     */
    public URL constructUrl (String link, String base)
        throws MalformedURLException
    {
<span class="nc" id="L879">        return (constructUrl (link, base, false));</span>
    }

    /**
     * Build a URL from the link and base provided.
     * @param link The (relative) URI.
     * @param base The base URL of the page, either from the &amp;lt;BASE&amp;gt; tag
     * or, if none, the URL the page is being fetched from.
     * @param strict If &lt;code&gt;true&lt;/code&gt; a link starting with '?' is handled
     * according to &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396&lt;/a&gt;,
     * otherwise the common interpretation of a query appended to the base
     * is used instead.
     * @return An absolute URL.
     * @exception MalformedURLException If creating the URL fails.
     */
    public URL constructUrl (String link, String base, boolean strict)
        throws MalformedURLException
    {
        String path;
        boolean modified;
        boolean absolute;
        int index;
        URL url; // constructed URL combining relative link and base

        // Bug #1461473 Relative links starting with ?
<span class="fc bfc" id="L904" title="All 4 branches covered.">        if (!strict &amp;&amp; ('?' == link.charAt (0)))</span>
        {   // remove query part of base if any
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">            if (-1 != (index = base.lastIndexOf ('?')))</span>
<span class="fc" id="L907">                base = base.substring (0, index);</span>
<span class="fc" id="L908">            url = new URL (base + link);</span>
<span class="fc" id="L909">        }</span>
        else
<span class="fc" id="L911">            url = new URL (new URL (base), link);</span>
<span class="fc" id="L912">        path = url.getFile ();</span>
<span class="fc" id="L913">        modified = false;</span>
<span class="fc" id="L914">        absolute = link.startsWith (&quot;/&quot;);</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">        if (!absolute)</span>
        {   // we prefer to fix incorrect relative links
            // this doesn't fix them all, just the ones at the start
<span class="fc bfc" id="L918" title="All 2 branches covered.">            while (path.startsWith (&quot;/.&quot;))</span>
            {
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">                if (path.startsWith (&quot;/../&quot;))</span>
                {
<span class="fc" id="L922">                    path = path.substring (3);</span>
<span class="fc" id="L923">                    modified = true;</span>
<span class="fc" id="L924">                }</span>
<span class="nc bnc" id="L925" title="All 4 branches missed.">                else if (path.startsWith (&quot;/./&quot;) || path.startsWith(&quot;/.&quot;))</span>
                {
<span class="nc" id="L927">                    path = path.substring (2);</span>
<span class="nc" id="L928">                    modified = true;</span>
                }
                else
                    break;
            }
        }
        // fix backslashes
<span class="fc bfc" id="L935" title="All 2 branches covered.">        while (-1 != (index = path.indexOf (&quot;/\\&quot;)))</span>
        {
<span class="fc" id="L937">            path = path.substring (0, index + 1) + path.substring (index + 2);</span>
<span class="fc" id="L938">            modified = true;</span>
        }
<span class="fc bfc" id="L940" title="All 2 branches covered.">        if (modified)</span>
<span class="fc" id="L941">            url = new URL (url, path);</span>

<span class="fc" id="L943">        return (url);</span>
    }

    /**
     * Create an absolute URL from a relative link.
     * @param link The reslative portion of a URL.
     * @return The fully qualified URL or the original link if it was absolute
     * already or a failure occured.
     */
    public String getAbsoluteURL (String link)
    {
<span class="fc" id="L954">        return (getAbsoluteURL (link, false));</span>
    }

    /**
     * Create an absolute URL from a relative link.
     * @param link The reslative portion of a URL.
     * @param strict If &lt;code&gt;true&lt;/code&gt; a link starting with '?' is handled
     * according to &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;RFC 2396&lt;/a&gt;,
     * otherwise the common interpretation of a query appended to the base
     * is used instead.
     * @return The fully qualified URL or the original link if it was absolute
     * already or a failure occured.
     */
    public String getAbsoluteURL (String link, boolean strict)
    {
        String base;
        URL url;
        String ret;

<span class="fc bfc" id="L973" title="All 4 branches covered.">        if ((null == link) || (&quot;&quot;.equals (link)))</span>
<span class="fc" id="L974">            ret = &quot;&quot;;</span>
        else
            try
            {
<span class="fc" id="L978">                base =  getBaseUrl ();</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">                if (null == base)</span>
<span class="fc" id="L980">                    base = getUrl ();</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">                if (null == base)</span>
<span class="fc" id="L982">                    ret = link;</span>
                else
                {
<span class="fc" id="L985">                    url = constructUrl (link, base, strict);</span>
<span class="fc" id="L986">                    ret = url.toExternalForm ();</span>
                }
<span class="fc" id="L988">            }</span>
<span class="fc" id="L989">            catch (MalformedURLException murle)</span>
            {
<span class="fc" id="L991">                ret = link;</span>
            }

<span class="fc" id="L994">        return (ret);</span>
    }

    /**
     * Get the line number for a cursor.
     * @param cursor The character offset into the page.
     * @return The line number the character is in.
     */
    public int row (Cursor cursor)
    {
<span class="fc" id="L1004">        return (mIndex.row (cursor));</span>
    }

    /**
     * Get the line number for a cursor.
     * @param position The character offset into the page.
     * @return The line number the character is in.
     */
    public int row (int position)
    {
<span class="fc" id="L1014">        return (mIndex.row (position));</span>
    }

    /**
     * Get the column number for a cursor.
     * @param cursor The character offset into the page.
     * @return The character offset into the line this cursor is on.
     */
    public int column (Cursor cursor)
    {
<span class="fc" id="L1024">        return (mIndex.column (cursor));</span>
    }

    /**
     * Get the column number for a cursor.
     * @param position The character offset into the page.
     * @return The character offset into the line this cursor is on.
     */
    public int column (int position)
    {
<span class="nc" id="L1034">        return (mIndex.column (position));</span>
    }

    /**
     * Get the text identified by the given limits.
     * @param start The starting position, zero based.
     * @param end The ending position
     * (exclusive, i.e. the character at the ending position is not included),
     * zero based.
     * @return The text from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;.
     * @see #getText(StringBuffer, int, int)
     * @exception IllegalArgumentException If an attempt is made to get
     * characters ahead of the current source offset (character position).
     */
    public String getText (int start, int end)
        throws
            IllegalArgumentException
    {
        String ret;

        try
        {
<span class="fc" id="L1056">            ret = mSource.getString (start, end - start);</span>
<span class="fc" id="L1057">        }</span>
<span class="nc" id="L1058">        catch (IOException ioe)</span>
        {
<span class="nc" id="L1060">            throw new IllegalArgumentException (</span>
<span class="nc" id="L1061">                &quot;can't get the &quot;</span>
<span class="nc" id="L1062">                + (end - start)</span>
<span class="nc" id="L1063">                + &quot;characters at position &quot;</span>
<span class="nc" id="L1064">                + start</span>
<span class="nc" id="L1065">                + &quot; - &quot;</span>
<span class="nc" id="L1066">                + ioe.getMessage ());</span>
        }

<span class="fc" id="L1069">        return (ret);</span>
    }

    /**
     * Put the text identified by the given limits into the given buffer.
     * @param buffer The accumulator for the characters.
     * @param start The starting position, zero based.
     * @param end The ending position
     * (exclusive, i.e. the character at the ending position is not included),
     * zero based.
     * @exception IllegalArgumentException If an attempt is made to get
     * characters ahead of the current source offset (character position).
     */
    public void getText (StringBuffer buffer, int start, int end)
        throws
            IllegalArgumentException
    {
        int length;

<span class="pc bpc" id="L1088" title="2 of 4 branches missed.">        if ((mSource.offset () &lt; start) || (mSource.offset () &lt; end))</span>
<span class="nc" id="L1089">            throw new IllegalArgumentException (</span>
<span class="nc" id="L1090">                &quot;attempt to extract future characters from source&quot;</span>
<span class="nc" id="L1091">                + start + &quot;|&quot; + end + &quot; &gt; &quot; + mSource.offset ());</span>
<span class="pc bpc" id="L1092" title="1 of 2 branches missed.">        if (end &lt; start)</span>
        {
<span class="nc" id="L1094">            length = end;</span>
<span class="nc" id="L1095">            end = start;</span>
<span class="nc" id="L1096">            start = length;</span>
        }
<span class="fc" id="L1098">        length = end - start;</span>
        try
        {
<span class="fc" id="L1101">            mSource.getCharacters (buffer, start, length);</span>
<span class="fc" id="L1102">        }</span>
<span class="nc" id="L1103">        catch (IOException ioe)</span>
        {
<span class="nc" id="L1105">            throw new IllegalArgumentException (</span>
<span class="nc" id="L1106">                &quot;can't get the &quot;</span>
<span class="nc" id="L1107">                + (end - start)</span>
<span class="nc" id="L1108">                + &quot;characters at position &quot;</span>
<span class="nc" id="L1109">                + start</span>
<span class="nc" id="L1110">                + &quot; - &quot;</span>
<span class="nc" id="L1111">                + ioe.getMessage ());</span>
        }
<span class="fc" id="L1113">    }</span>

    /**
     * Get all text read so far from the source.
     * @return The text from the source.
     * @see #getText(StringBuffer)
     */
    public String getText ()
    {
<span class="nc" id="L1122">        return (getText (0, mSource.offset ()));</span>
    }

    /**
     * Put all text read so far from the source into the given buffer.
     * @param buffer The accumulator for the characters.
     * @see #getText(StringBuffer,int,int)
     */
    public void getText (StringBuffer buffer)
    {
<span class="nc" id="L1132">        getText (buffer, 0, mSource.offset ());</span>
<span class="nc" id="L1133">    }</span>

    /**
     * Put the text identified by the given limits into the given array at the specified offset.
     * @param array The array of characters.
     * @param offset The starting position in the array where characters are to be placed.
     * @param start The starting position, zero based.
     * @param end The ending position
     * (exclusive, i.e. the character at the ending position is not included),
     * zero based.
     * @exception IllegalArgumentException If an attempt is made to get
     * characters ahead of the current source offset (character position).
     */
    public void getText (char[] array, int offset, int start, int end)
        throws
            IllegalArgumentException
    {
        int length;

<span class="nc bnc" id="L1152" title="All 4 branches missed.">        if ((mSource.offset () &lt; start) || (mSource.offset () &lt; end))</span>
<span class="nc" id="L1153">            throw new IllegalArgumentException (&quot;attempt to extract future characters from source&quot;);</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (end &lt; start)</span>
        {   // swap
<span class="nc" id="L1156">            length = end;</span>
<span class="nc" id="L1157">            end = start;</span>
<span class="nc" id="L1158">            start = length;</span>
        }
<span class="nc" id="L1160">        length = end - start;</span>
        try
        {
<span class="nc" id="L1163">            mSource.getCharacters (array, offset, start, end);</span>
<span class="nc" id="L1164">        }</span>
<span class="nc" id="L1165">        catch (IOException ioe)</span>
        {
<span class="nc" id="L1167">            throw new IllegalArgumentException (</span>
<span class="nc" id="L1168">                &quot;can't get the &quot;</span>
<span class="nc" id="L1169">                + (end - start)</span>
<span class="nc" id="L1170">                + &quot;characters at position &quot;</span>
<span class="nc" id="L1171">                + start</span>
<span class="nc" id="L1172">                + &quot; - &quot;</span>
<span class="nc" id="L1173">                + ioe.getMessage ());</span>
        }
<span class="nc" id="L1175">    }</span>

    /**
     * Get the text line the position of the cursor lies on.
     * @param cursor The position to calculate for.
     * @return The contents of the URL or file corresponding to the line number
     * containing the cursor position.
     */
    public String getLine (Cursor cursor)
    {
        int line;
        int size;
        int start;
        int end;

<span class="nc" id="L1190">        line = row (cursor);</span>
<span class="nc" id="L1191">        size = mIndex.size ();</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">        if (line &lt; size)</span>
        {
<span class="nc" id="L1194">            start = mIndex.elementAt (line);</span>
<span class="nc" id="L1195">            line++;</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            if (line &lt;= size)</span>
<span class="nc" id="L1197">                end = mIndex.elementAt (line);</span>
            else
<span class="nc" id="L1199">                end = mSource.offset ();</span>
<span class="nc" id="L1200">        }</span>
        else // current line
        {
<span class="nc" id="L1203">            start = mIndex.elementAt (line - 1);</span>
<span class="nc" id="L1204">            end = mSource.offset ();</span>
        }
        
            
<span class="nc" id="L1208">        return (getText (start,  end));</span>
    }

    /**
     * Get the text line the position of the cursor lies on.
     * @param position The position to calculate for.
     * @return The contents of the URL or file corresponding to the line number
     * containg the cursor position.
     */
    public String getLine (int position)
    {
<span class="nc" id="L1219">        return (getLine (new Cursor (this, position)));</span>
    }
    
    /**
     * Display some of this page as a string.
     * @return The last few characters the source read in.
     */
    public String toString ()
    {
        StringBuffer buffer;
        int start;
        String ret;

<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (mSource.offset () &gt; 0)</span>
        {
<span class="nc" id="L1234">            buffer = new StringBuffer (43);</span>
<span class="nc" id="L1235">            start = mSource.offset () - 40;</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">            if (0 &gt; start)</span>
<span class="nc" id="L1237">                start = 0;</span>
            else
<span class="nc" id="L1239">                buffer.append (&quot;...&quot;);</span>
<span class="nc" id="L1240">            getText (buffer, start, mSource.offset ());</span>
<span class="nc" id="L1241">            ret = buffer.toString ();</span>
<span class="nc" id="L1242">        }</span>
        else
<span class="nc" id="L1244">            ret = super.toString ();</span>
        
<span class="nc" id="L1246">        return (ret);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (4) (Oct 27, 2015 3:17:09 PM)</div></body></html>