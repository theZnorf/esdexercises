<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Lexer.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (4) (Oct 27, 2015 3:17:09 PM)</a> &gt; <a href="../../index.html" class="el_group">HTMLParser-2.0-SNAPSHOT</a> &gt; <a href="../index.html" class="el_bundle">lexer/src/main/java</a> &gt; <a href="index.source.html" class="el_package">org.htmlparser.lexer</a> &gt; <span class="el_source">Lexer.java</span></div><h1>Lexer.java</h1><pre class="source lang-java linenums">// HTMLParser Library - A java-based parser for HTML
// http://htmlparser.org
// Copyright (C) 2006 Derrick Oswald
//
// Revision Control Information
//
// $URL: https://svn.sourceforge.net/svnroot/htmlparser/trunk/lexer/src/main/java/org/htmlparser/lexer/Lexer.java $
// $Author: derrickoswald $
// $Date: 2006-09-23 00:23:10 -0400 (Sat, 23 Sep 2006) $
// $Revision: 13 $
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the Common Public License; either
// version 1.0 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// Common Public License for more details.
//
// You should have received a copy of the Common Public License
// along with this library; if not, the license is available from
// the Open Source Initiative (OSI) website:
//   http://opensource.org/licenses/cpl1.0.php

package org.htmlparser.lexer;

import java.io.Serializable;
import java.net.MalformedURLException;
import java.net.URLConnection;
import java.util.Vector;

import org.htmlparser.Node;
import org.htmlparser.NodeFactory;
import org.htmlparser.Remark;
import org.htmlparser.Text;
import org.htmlparser.Tag;
import org.htmlparser.http.ConnectionManager;
import org.htmlparser.nodes.RemarkNode;
import org.htmlparser.nodes.TextNode;
import org.htmlparser.nodes.TagNode;
import org.htmlparser.util.ParserException;

/**
 * This class parses the HTML stream into nodes.
 * There are three major types of nodes (lexemes):
 * &lt;ul&gt;
 * &lt;li&gt;Remark&lt;/li&gt;
 * &lt;li&gt;Text&lt;/li&gt;
 * &lt;li&gt;Tag&lt;/li&gt;
 * &lt;/ul&gt;
 * Each time &lt;code&gt;nextNode()&lt;/code&gt; is called, another node is returned until
 * the stream is exhausted, and &lt;code&gt;null&lt;/code&gt; is returned.
 */
public class Lexer
    implements
        Serializable,
        NodeFactory
{
    // Please don't change the formatting of the version variables below.
    // This is done so as to facilitate ant script processing.

    /**
     * The floating point version number ({@value}).
     */
    public static final double
    VERSION_NUMBER = 2.0
    ;

    /**
     * The type of version ({@value}).
     */
    public static final String
    VERSION_TYPE = &quot;Release Build&quot;
    ;

    /**
     * The date of the version ({@value}).
     */
    public static final String
    VERSION_DATE = &quot;Sep 17, 2006&quot;
    ;

    // End of formatting

    /**
     * The display version ({@value}).
     */
    public static final String VERSION_STRING =
            &quot;&quot; + VERSION_NUMBER
            + &quot; (&quot; + VERSION_TYPE + &quot; &quot; + VERSION_DATE + &quot;)&quot;;

    /**
     * Process remarks strictly flag.
     * If &lt;code&gt;true&lt;/code&gt;, remarks are not terminated by ---$gt;
     * or --!$gt;, i.e. more than two dashes. If &lt;code&gt;false&lt;/code&gt;,
     * a more lax (and closer to typical browser handling) remark parsing
     * is used.
     * Default &lt;code&gt;true&lt;/code&gt;.
     */
<span class="fc" id="L101">    public static boolean STRICT_REMARKS = true;</span>

    /**
     * The page lexemes are retrieved from.
     */
    protected Page mPage;

    /**
     * The current position on the page.
     */
    protected Cursor mCursor;

    /**
     * The factory for new nodes.
     */
    protected NodeFactory mFactory;

    /**
     * Line number to trigger on.
     * This is tested on each &lt;code&gt;nextNode()&lt;/code&gt; call, as a debugging aid.
     * Alter this value and set a breakpoint on the guarded statement.
     * Remember, these line numbers are zero based, while most editors are
     * one based.
     * @see #nextNode
     */
<span class="fc" id="L126">    protected static int mDebugLineTrigger = -1;</span>

    //
    // Static methods
    //

    /**
     * Return the version string of this parser.
     * @return A string of the form:
     * &lt;pre&gt;
     * &quot;[floating point number] ([build-type] [build-date])&quot;
     * &lt;/pre&gt;
     */
    public static String getVersion ()
    {
<span class="nc" id="L141">        return (VERSION_STRING);</span>
    }

    //
    // Constructors
    //

    /**
     * Creates a new instance of a Lexer.
     */
    public Lexer ()
    {
<span class="fc" id="L153">        this (new Page (&quot;&quot;));</span>
<span class="fc" id="L154">    }</span>

    /**
     * Creates a new instance of a Lexer.
     * @param page The page with HTML text.
     */
<span class="fc" id="L160">    public Lexer (Page page)</span>
    {
<span class="fc" id="L162">        setPage (page);</span>
<span class="fc" id="L163">        setCursor (new Cursor (page, 0));</span>
<span class="fc" id="L164">        setNodeFactory (this);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Creates a new instance of a Lexer.
     * @param text The text to parse.
     */
    public Lexer (String text)
    {
<span class="fc" id="L173">        this (new Page (text));</span>
<span class="fc" id="L174">    }</span>

    /**
     * Creates a new instance of a Lexer.
     * @param connection The url to parse.
     * @exception ParserException If an error occurs opening the connection.
     */
    public Lexer (URLConnection connection)
        throws
            ParserException
    {
<span class="fc" id="L185">        this (new Page (connection));</span>
<span class="fc" id="L186">    }</span>

    //
    // Bean patterns
    //

    /**
     * Get the page this lexer is working on.
     * @return The page that nodes are being read from.
     */
    public Page getPage ()
    {
<span class="fc" id="L198">        return (mPage);</span>
    }

    /**
     * Set the page this lexer is working on.
     * @param page The page that nodes will be read from.
     */
    public void setPage (Page page)
    {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (null == page)</span>
<span class="nc" id="L208">            throw new IllegalArgumentException (&quot;page cannot be null&quot;);</span>
        // todo: sanity checks
<span class="fc" id="L210">        mPage = page;</span>
<span class="fc" id="L211">    }</span>

    /**
     * Get the current scanning position.
     * @return The lexer's cursor position.
     */
    public Cursor getCursor ()
    {
<span class="fc" id="L219">        return (mCursor);</span>
    }

    /**
     * Set the current scanning position.
     * @param cursor The lexer's new cursor position.
     */
    public void setCursor (Cursor cursor)
    {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (null == cursor)</span>
<span class="nc" id="L229">            throw new IllegalArgumentException (&quot;cursor cannot be null&quot;);</span>
        // todo: sanity checks
<span class="fc" id="L231">        mCursor = cursor;</span>
<span class="fc" id="L232">    }</span>

    /**
     * Get the current node factory.
     * @return The lexer's node factory.
     */
    public NodeFactory getNodeFactory ()
    {
<span class="fc" id="L240">        return (mFactory);</span>
    }

    /**
     * Set the current node factory.
     * @param factory The node factory to be used by the lexer.
     */
    public void setNodeFactory (NodeFactory factory)
    {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (null == factory)</span>
<span class="nc" id="L250">            throw new IllegalArgumentException (&quot;node factory cannot be null&quot;);</span>
<span class="fc" id="L251">        mFactory = factory;</span>
<span class="fc" id="L252">    }</span>

    /**
     * Get the current cursor position.
     * @return The current character offset into the source.
     */
    public int getPosition ()
    {
<span class="fc" id="L260">        return (getCursor ().getPosition ());</span>
    }

    /**
     * Set the current cursor position.
     * @param position The new character offset into the source.
     */
    public void setPosition (int position)
    {
        // todo: sanity checks
<span class="fc" id="L270">        getCursor ().setPosition (position);</span>
<span class="fc" id="L271">    }</span>

    /**
     * Get the current line number.
     * @return The line number the lexer's working on.
     */
    public int getCurrentLineNumber ()
    {
<span class="nc" id="L279">        return (getPage ().row (getCursor ()));</span>
    }

    /**
     * Get the current line.
     * @return The string the lexer's working on.
     */
    public String getCurrentLine ()
    {
<span class="nc" id="L288">        return (getPage ().getLine (getCursor ()));</span>
    }

    //
    // Public methods
    //

    /**
     * Reset the lexer to start parsing from the beginning again.
     * The underlying components are reset such that the next call to
     * &lt;code&gt;nextNode()&lt;/code&gt; will return the first lexeme on the page.
     */
    public void reset ()
    {
<span class="fc" id="L302">        getPage ().reset ();</span>
<span class="fc" id="L303">        setCursor (new Cursor (getPage (), 0));</span>
<span class="fc" id="L304">    }</span>

    /**
     * Get the next node from the source.
     * @return A Remark, Text or Tag, or &lt;code&gt;null&lt;/code&gt; if no
     * more lexemes are present.
     * @exception ParserException If there is a problem with the
     * underlying page.
     */
    public Node nextNode ()
        throws
            ParserException
    {
<span class="fc" id="L317">        return nextNode (false);</span>
    }

    /**
     * Get the next node from the source.
     * @param quotesmart If &lt;code&gt;true&lt;/code&gt;, strings ignore quoted contents.
     * @return A Remark, Text or Tag, or &lt;code&gt;null&lt;/code&gt; if no
     * more lexemes are present.
     * @exception ParserException If there is a problem with the
     * underlying page.
     */
    public Node nextNode (boolean quotesmart)
        throws
            ParserException
    {
        int start;
        char ch;
        Node ret;

        // debugging suppport
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (-1 != mDebugLineTrigger)</span>
        {
<span class="nc" id="L339">            Page page = getPage ();</span>
<span class="nc" id="L340">            int lineno = page.row (mCursor);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (mDebugLineTrigger &lt; lineno)</span>
<span class="nc" id="L342">                mDebugLineTrigger = lineno + 1; // trigger on next line too</span>
        }
<span class="fc" id="L344">        start = mCursor.getPosition ();</span>
<span class="fc" id="L345">        ch = mPage.getCharacter (mCursor);</span>
<span class="fc bfc" id="L346" title="All 3 branches covered.">        switch (ch)</span>
        {
            case Page.EOF:
<span class="fc" id="L349">                ret = null;</span>
<span class="fc" id="L350">                break;</span>
            case '&lt;':
<span class="fc" id="L352">                ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                if (Page.EOF == ch)</span>
<span class="nc" id="L354">                    ret = makeString (start, mCursor.getPosition ());</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">                else if ('%' == ch)</span>
                {
<span class="fc" id="L357">                    mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L358">                    ret = parseJsp (start);</span>
<span class="fc" id="L359">                }</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                else if ('?' == ch)</span>
                {
<span class="fc" id="L362">                    mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L363">                    ret = parsePI (start);</span>
<span class="fc" id="L364">                }</span>
<span class="pc bpc" id="L365" title="1 of 6 branches missed.">                else if ('/' == ch || '%' == ch || Character.isLetter (ch))</span>
                {
<span class="fc" id="L367">                    mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L368">                    ret = parseTag (start);</span>
<span class="fc" id="L369">                }</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">                else if ('!' == ch)</span>
                {
<span class="fc" id="L372">                    ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">                    if (Page.EOF == ch)</span>
<span class="nc" id="L374">                        ret = makeString (start, mCursor.getPosition ());</span>
                    else
                    {
<span class="fc bfc" id="L377" title="All 2 branches covered.">                        if ('&gt;' == ch) // handle &lt;!&gt;</span>
<span class="fc" id="L378">                            ret = makeRemark (start, mCursor.getPosition ());</span>
                        else
                        {
<span class="fc" id="L381">                            mPage.ungetCharacter (mCursor); // remark/tag need this char</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                            if ('-' == ch)</span>
<span class="fc" id="L383">                                ret = parseRemark (start, quotesmart);</span>
                            else
                            {
<span class="fc" id="L386">                                mPage.ungetCharacter (mCursor); // tag needs prior one too</span>
<span class="fc" id="L387">                                ret = parseTag (start);</span>
                            }
                        }
                    }
<span class="fc" id="L391">                }</span>
                else
                {
<span class="fc" id="L394">                    mPage.ungetCharacter (mCursor); // see bug #1547354 &lt;&lt;tag&gt; parsed as text</span>
<span class="fc" id="L395">                    ret = parseString (start, quotesmart);</span>
                }
<span class="fc" id="L397">                break;</span>
            default:
<span class="fc" id="L399">                mPage.ungetCharacter (mCursor); // string needs to see leading foreslash</span>
<span class="fc" id="L400">                ret = parseString (start, quotesmart);</span>
                break;
        }

<span class="fc" id="L404">        return (ret);</span>
    }

    /**
     * Return CDATA as a text node.
     * According to appendix &lt;a href=&quot;http://www.w3.org/TR/html4/appendix/notes.html#notes-specifying-data&quot;&gt;
     * B.3.2 Specifying non-HTML data&lt;/a&gt; of the
     * &lt;a href=&quot;http://www.w3.org/TR/html4/&quot;&gt;HTML 4.01 Specification&lt;/a&gt;:&lt;br&gt;
     * &lt;quote&gt;
     * &lt;b&gt;Element content&lt;/b&gt;&lt;br&gt;
     * When script or style data is the content of an element (SCRIPT and STYLE),
     * the data begins immediately after the element start tag and ends at the
     * first ETAGO (&quot;&amp;lt;/&quot;) delimiter followed by a name start character ([a-zA-Z]);
     * note that this may not be the element's end tag.
     * Authors should therefore escape &quot;&amp;lt;/&quot; within the content. Escape mechanisms
     * are specific to each scripting or style sheet language.
     * &lt;/quote&gt;
     * @return The &lt;code&gt;TextNode&lt;/code&gt; of the CDATA or &lt;code&gt;null&lt;/code&gt; if none.
     * @exception ParserException If a problem occurs reading from the source.
     */
    public Node parseCDATA ()
        throws
            ParserException
    {
<span class="fc" id="L428">        return (parseCDATA (false));</span>
    }

    /**
     * Return CDATA as a text node.
     * Slightly less rigid than {@link #parseCDATA()} this method provides for
     * parsing CDATA that may contain quoted strings that have embedded
     * ETAGO (&quot;&amp;lt;/&quot;) delimiters and skips single and multiline comments.
     * @param quotesmart If &lt;code&gt;true&lt;/code&gt; the strict definition of CDATA is
     * extended to allow for single or double quoted ETAGO (&quot;&amp;lt;/&quot;) sequences.
     * @return The &lt;code&gt;TextNode&lt;/code&gt; of the CDATA or &lt;code&gt;null&lt;/code&gt; if none.
     * @see #parseCDATA()
     * @exception ParserException If a problem occurs reading from the source.
     */
    public Node parseCDATA (boolean quotesmart)
        throws
            ParserException
    {
        int start;
        int state;
        boolean done;
        char quote;
        char ch;
        int end;
        boolean comment;

<span class="fc" id="L454">        start = mCursor.getPosition ();</span>
<span class="fc" id="L455">        state = 0;</span>
<span class="fc" id="L456">        done = false;</span>
<span class="fc" id="L457">        quote = 0;</span>
<span class="fc" id="L458">        comment = false;</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">        while (!done)</span>
        {
<span class="fc" id="L462">            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L463" title="1 of 5 branches missed.">            switch (state)</span>
            {
                case 0: // prior to ETAGO
<span class="fc bfc" id="L466" title="All 8 branches covered.">                    switch (ch)</span>
                    {
                        case Page.EOF:
<span class="fc" id="L469">                            done = true;</span>
<span class="fc" id="L470">                            break;</span>
                        case '\'':
<span class="fc bfc" id="L472" title="All 4 branches covered.">                            if (quotesmart &amp;&amp; !comment)</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                                if (0 == quote)</span>
<span class="fc" id="L474">                                    quote = '\''; // enter quoted state</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">                                else if ('\'' == quote)</span>
<span class="fc" id="L476">                                    quote = 0; // exit quoted state</span>
<span class="fc" id="L477">                            break;</span>
                        case '&quot;':
<span class="pc bpc" id="L479" title="1 of 4 branches missed.">                            if (quotesmart &amp;&amp; !comment)</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                                if (0 == quote)</span>
<span class="fc" id="L481">                                    quote = '&quot;'; // enter quoted state</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                                else if ('&quot;' == quote)</span>
<span class="fc" id="L483">                                    quote = 0; // exit quoted state</span>
<span class="fc" id="L484">                            break;</span>
                        case '\\':
<span class="fc bfc" id="L486" title="All 2 branches covered.">                            if (quotesmart)</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">                                if (0 != quote)</span>
                                {
<span class="fc" id="L489">                                    ch = mPage.getCharacter (mCursor); // try to consume escaped character</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                                    if (Page.EOF == ch)</span>
<span class="nc" id="L491">                                        done = true;</span>
<span class="pc bpc" id="L492" title="2 of 4 branches missed.">                                    else if (  (ch != '\\') &amp;&amp; (ch != quote))</span>
                                        // unconsume char if character was not an escapable char.
<span class="nc" id="L494">                                        mPage.ungetCharacter (mCursor);</span>
                                }
<span class="nc" id="L496">                            break;</span>
                        case '/':
<span class="fc bfc" id="L498" title="All 2 branches covered.">                            if (quotesmart)</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">                                if (0 == quote)</span>
                                {
                                    // handle multiline and double slash comments (with a quote)
<span class="fc" id="L502">                                    ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">                                    if (Page.EOF == ch)</span>
<span class="nc" id="L504">                                        done = true;</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">                                    else if ('/' == ch)</span>
<span class="fc" id="L506">                                        comment = true;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                                    else if ('*' == ch)</span>
                                    {
                                        do
                                        {
                                            do
<span class="nc" id="L512">                                                ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L513" title="All 4 branches missed.">                                            while ((Page.EOF != ch) &amp;&amp; ('*' != ch));</span>
<span class="nc" id="L514">                                            ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                                            if (ch == '*')</span>
<span class="nc" id="L516">                                                mPage.ungetCharacter (mCursor);</span>
                                        }
<span class="nc bnc" id="L518" title="All 4 branches missed.">                                        while ((Page.EOF != ch) &amp;&amp; ('/' != ch));</span>
<span class="nc" id="L519">                                    }</span>
                                    else
<span class="nc" id="L521">                                        mPage.ungetCharacter (mCursor);</span>
                                }
<span class="nc" id="L523">                            break;</span>
                        case '\n':
<span class="fc" id="L525">                            comment = false;</span>
<span class="fc" id="L526">                            break;</span>
                        case '&lt;':
<span class="fc bfc" id="L528" title="All 2 branches covered.">                            if (quotesmart)</span>
                            {
<span class="fc bfc" id="L530" title="All 2 branches covered.">                                if (0 == quote)</span>
<span class="fc" id="L531">                                    state = 1;</span>
<span class="fc" id="L532">                            }</span>
                            else
<span class="fc" id="L534">                                state = 1;</span>
<span class="fc" id="L535">                            break;</span>
                        default:
                            break;
                    }
<span class="fc" id="L539">                    break;</span>
                case 1: // &lt;
<span class="pc bpc" id="L541" title="1 of 4 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF:
<span class="nc" id="L544">                            done = true;</span>
<span class="nc" id="L545">                            break;</span>
                        case '/':
<span class="fc" id="L547">                            state = 2;</span>
<span class="fc" id="L548">                            break;</span>
                        case '!':
<span class="fc" id="L550">                            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                            if (Page.EOF == ch)</span>
<span class="nc" id="L552">                                done = true;</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                            else if ('-' == ch)</span>
                            {
<span class="fc" id="L555">                                ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">                                if (Page.EOF == ch)</span>
<span class="nc" id="L557">                                    done = true;</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">                                else if ('-' == ch)</span>
<span class="fc" id="L559">                                    state = 3;</span>
                                else
<span class="nc" id="L561">                                    state = 0;</span>
<span class="nc" id="L562">                            }</span>
                            else
<span class="nc" id="L564">                                state = 0;</span>
<span class="nc" id="L565">                            break;</span>
                        default:
<span class="fc" id="L567">                            state = 0;</span>
                            break;
                    }
<span class="fc" id="L570">                    break;</span>
                case 2: // &lt;/
<span class="fc" id="L572">                    comment = false;</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                    if (Page.EOF == ch)</span>
<span class="nc" id="L574">                        done = true;</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                    else if (Character.isLetter (ch))</span>
                    {
<span class="fc" id="L577">                        done = true;</span>
                        // back up to the start of ETAGO
<span class="fc" id="L579">                        mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L580">                        mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L581">                        mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L582">                    }</span>
                    else
<span class="nc" id="L584">                        state = 0;</span>
<span class="nc" id="L585">                    break;</span>
                case 3: // &lt;!
<span class="fc" id="L587">                    comment = false;</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                    if (Page.EOF == ch)</span>
<span class="fc" id="L589">                        done = true;</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                    else if ('-' == ch)</span>
                    {
<span class="fc" id="L592">                        ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">                        if (Page.EOF == ch)</span>
<span class="nc" id="L594">                            done = true;</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                        else if ('-' == ch)</span>
                        {
<span class="fc" id="L597">                            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">                            if (Page.EOF == ch)</span>
<span class="nc" id="L599">                                done = true;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">                            else if ('&gt;' == ch)</span>
<span class="fc" id="L601">                                state = 0;</span>
                            else
                            {
<span class="fc" id="L604">                                mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L605">                                mPage.ungetCharacter (mCursor);</span>
                            }
<span class="fc" id="L607">                        }</span>
                        else
<span class="fc" id="L609">                            mPage.ungetCharacter (mCursor);</span>
                    }
<span class="fc" id="L611">                    break;</span>
                default:
<span class="nc" id="L613">                    throw new IllegalStateException (&quot;how the fuck did we get in state &quot; + state);</span>
            }
        }
<span class="fc" id="L616">        end = mCursor.getPosition ();</span>

<span class="fc" id="L618">        return (makeString (start, end));</span>
    }

    //
    // NodeFactory interface
    //

    /**
     * Create a new string node.
     * @param page The page the node is on.
     * @param start The beginning position of the string.
     * @param end The ending positiong of the string.
     * @return The created Text node.
     */
    public Text createStringNode (Page page,  int start, int end)
    {
<span class="fc" id="L634">        return (new TextNode (page, start, end));</span>
    }

    /**
     * Create a new remark node.
     * @param page The page the node is on.
     * @param start The beginning position of the remark.
     * @param end The ending positiong of the remark.
     * @return The created Remark node.
     */
    public Remark createRemarkNode (Page page,  int start, int end)
    {
<span class="fc" id="L646">        return (new RemarkNode (page, start, end));</span>
    }

    /**
     * Create a new tag node.
     * Note that the attributes vector contains at least one element,
     * which is the tag name (standalone attribute) at position zero.
     * This can be used to decide which type of node to create, or
     * gate other processing that may be appropriate.
     * @param page The page the node is on.
     * @param start The beginning position of the tag.
     * @param end The ending positiong of the tag.
     * @param attributes The attributes contained in this tag.
     * @return The created Tag node.
     */
    public Tag createTagNode (Page page, int start, int end, Vector attributes)
    {
<span class="fc" id="L663">        return (new TagNode (page, start, end, attributes));</span>
    }

    //
    // Internal methods
    //

    /**
     * Advance the cursor through a JIS escape sequence.
     * @param cursor A cursor positioned within the escape sequence.
     * @exception ParserException If a problem occurs reading from the source.
     */
    protected void scanJIS (Cursor cursor)
        throws
            ParserException
    {
        boolean done;
        char ch;
        int state;

<span class="nc" id="L683">        done = false;</span>
<span class="nc" id="L684">        state = 0;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        while (!done)</span>
        {
<span class="nc" id="L687">            ch = mPage.getCharacter (cursor);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">            if (Page.EOF == ch)</span>
<span class="nc" id="L689">                done = true;</span>
            else
<span class="nc bnc" id="L691" title="All 4 branches missed.">                switch (state)</span>
                {
                    case 0:
<span class="nc bnc" id="L694" title="All 2 branches missed.">                        if (0x1b == ch) // escape</span>
<span class="nc" id="L695">                            state = 1;</span>
<span class="nc" id="L696">                        break;</span>
                    case 1:
<span class="nc bnc" id="L698" title="All 2 branches missed.">                        if ('(' == ch)</span>
<span class="nc" id="L699">                            state = 2;</span>
                        else
<span class="nc" id="L701">                            state = 0;</span>
<span class="nc" id="L702">                        break;</span>
                    case 2:
<span class="nc bnc" id="L704" title="All 2 branches missed.">                        if ('J' == ch)</span>
<span class="nc" id="L705">                            done = true;</span>
                        else
<span class="nc" id="L707">                            state = 0;</span>
<span class="nc" id="L708">                        break;</span>
                    default:
<span class="nc" id="L710">                        throw new IllegalStateException (&quot;state &quot; + state);</span>
                }
        }
<span class="nc" id="L713">    }</span>

    /**
     * Parse a string node.
     * Scan characters until &quot;&amp;lt;/&quot;, &quot;&amp;lt;%&quot;, &quot;&amp;lt;!&quot; or &amp;lt; followed by a
     * letter is encountered, or the input stream is exhausted, in which
     * case &lt;code&gt;null&lt;/code&gt; is returned.
     * @param start The position at which to start scanning.
     * @param quotesmart If &lt;code&gt;true&lt;/code&gt;, strings ignore quoted contents.
     * @return The parsed node.
     * @exception ParserException If a problem occurs reading from the source.
     */
    protected Node parseString (int start, boolean quotesmart)
        throws
            ParserException
    {
        boolean done;
        char ch;
        char quote;

<span class="fc" id="L733">        done = false;</span>
<span class="fc" id="L734">        quote = 0;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">        while (!done)</span>
        {
<span class="fc" id="L737">            ch = mPage.getCharacter (mCursor);</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">            if (Page.EOF == ch)</span>
<span class="fc" id="L739">                done = true;</span>
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">            else if (0x1b == ch) // escape</span>
            {
<span class="nc" id="L742">                ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                if (Page.EOF == ch)</span>
<span class="nc" id="L744">                    done = true;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">                else if ('$' == ch)</span>
                {
<span class="nc" id="L747">                    ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                    if (Page.EOF == ch)</span>
<span class="nc" id="L749">                        done = true;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                    else if ('B' == ch)</span>
<span class="nc" id="L751">                        scanJIS (mCursor);</span>
                    else
                    {
<span class="nc" id="L754">                        mPage.ungetCharacter (mCursor);</span>
<span class="nc" id="L755">                        mPage.ungetCharacter (mCursor);</span>
                    }
<span class="nc" id="L757">                }</span>
                else
<span class="nc" id="L759">                    mPage.ungetCharacter (mCursor);</span>
<span class="nc" id="L760">            }</span>
<span class="fc bfc" id="L761" title="All 4 branches covered.">            else if (quotesmart &amp;&amp; (0 == quote)</span>
<span class="pc bpc" id="L762" title="1 of 4 branches missed.">                &amp;&amp; (('\'' == ch) || ('&quot;' == ch)))</span>
<span class="fc" id="L763">                quote = ch; // enter quoted state</span>
            // patch from Gernot Fricke to handle escaped closing quote
<span class="fc bfc" id="L765" title="All 6 branches covered.">            else if (quotesmart &amp;&amp; (0 != quote) &amp;&amp; ('\\' == ch))</span>
            {
<span class="fc" id="L767">                ch = mPage.getCharacter (mCursor); // try to consume escape</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">                if ((Page.EOF != ch)</span>
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">                    &amp;&amp; ('\\' != ch) // escaped backslash</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">                    &amp;&amp; (ch != quote)) // escaped quote character</span>
                       // ( reflects [&quot;] or [']  whichever opened the quotation)
<span class="nc" id="L772">                    mPage.ungetCharacter (mCursor); // unconsume char if char not an escape</span>
<span class="nc" id="L773">            }</span>
<span class="fc bfc" id="L774" title="All 4 branches covered.">            else if (quotesmart &amp;&amp; (ch == quote))</span>
<span class="fc" id="L775">                quote = 0; // exit quoted state</span>
<span class="pc bpc" id="L776" title="2 of 6 branches missed.">            else if (quotesmart &amp;&amp; (0 == quote) &amp;&amp; (ch == '/'))</span>
            {
                // handle multiline and double slash comments (with a quote)
                // in script like:
                // I can't handle single quotations.
<span class="nc" id="L781">                ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                if (Page.EOF == ch)</span>
<span class="nc" id="L783">                    done = true;</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                else if ('/' == ch)</span>
                {
                    do
<span class="nc" id="L787">                        ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L788" title="All 4 branches missed.">                    while ((Page.EOF != ch) &amp;&amp; ('\n' != ch));</span>
<span class="nc" id="L789">                }</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">                else if ('*' == ch)</span>
                {
                    do
                    {
                        do
<span class="nc" id="L795">                            ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L796" title="All 4 branches missed.">                        while ((Page.EOF != ch) &amp;&amp; ('*' != ch));</span>
<span class="nc" id="L797">                        ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                        if (ch == '*')</span>
<span class="nc" id="L799">                            mPage.ungetCharacter (mCursor);</span>
                    }
<span class="nc bnc" id="L801" title="All 4 branches missed.">                    while ((Page.EOF != ch) &amp;&amp; ('/' != ch));</span>
<span class="nc" id="L802">                }</span>
                else
<span class="nc" id="L804">                    mPage.ungetCharacter (mCursor);</span>
<span class="nc" id="L805">            }</span>
<span class="pc bpc" id="L806" title="1 of 4 branches missed.">            else if ((0 == quote) &amp;&amp; ('&lt;' == ch))</span>
            {
<span class="fc" id="L808">                ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">                if (Page.EOF == ch)</span>
<span class="nc" id="L810">                    done = true;</span>
                // the order of these tests might be optimized for speed:
<span class="fc bfc" id="L812" title="All 4 branches covered.">                else if ('/' == ch || Character.isLetter (ch)</span>
<span class="fc bfc" id="L813" title="All 6 branches covered.">                    || '!' == ch || '%' == ch || '?' == ch)</span>
                {
<span class="fc" id="L815">                    done = true;</span>
<span class="fc" id="L816">                    mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L817">                    mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L818">                }</span>
                else
                {
                    // it's not a tag, so keep going, but check for quotes
<span class="fc" id="L822">                    mPage.ungetCharacter (mCursor);</span>
                }
            }
        }

<span class="fc" id="L827">        return (makeString (start, mCursor.getPosition ()));</span>
    }

    /**
     * Create a string node based on the current cursor and the one provided.
     * @param start The starting point of the node.
     * @param end The ending point of the node.
     * @exception ParserException If the nodefactory creation of the text
     * node fails.
     * @return The new Text node.
     */
    protected Node makeString (int start, int end)
        throws
            ParserException
    {
        int length;
        Node ret;

<span class="fc" id="L845">        length = end - start;</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">        if (0 != length)</span>
            // got some characters
<span class="fc" id="L848">            ret = getNodeFactory ().createStringNode (</span>
<span class="fc" id="L849">                this.getPage (), start, end);</span>
        else
<span class="fc" id="L851">            ret = null;</span>

<span class="fc" id="L853">        return (ret);</span>
    }

    /**
     * Generate a whitespace 'attribute',
     * @param attributes The list so far.
     * @param bookmarks The array of positions.
     */
    private void whitespace (Vector attributes, int[] bookmarks)
    {
<span class="fc bfc" id="L863" title="All 2 branches covered.">        if (bookmarks[1] &gt; bookmarks[0])</span>
<span class="fc" id="L864">            attributes.addElement (new PageAttribute (</span>
<span class="fc" id="L865">                mPage, -1, -1, bookmarks[0], bookmarks[1], (char)0));</span>
<span class="fc" id="L866">    }</span>

    /**
     * Generate a standalone attribute -- font.
     * @param attributes The list so far.
     * @param bookmarks The array of positions.
     */
    private void standalone (Vector attributes, int[] bookmarks)
    {
<span class="fc" id="L875">        attributes.addElement (new PageAttribute (</span>
<span class="fc" id="L876">            mPage, bookmarks[1], bookmarks[2], -1, -1, (char)0));</span>
<span class="fc" id="L877">    }</span>

    /**
     * Generate an empty attribute -- color=.
     * @param attributes The list so far.
     * @param bookmarks The array of positions.
     */
    private void empty (Vector attributes, int[] bookmarks)
    {
<span class="fc" id="L886">        attributes.addElement (new PageAttribute (</span>
<span class="fc" id="L887">            mPage, bookmarks[1], bookmarks[2], bookmarks[2] + 1, -1, (char)0));</span>
<span class="fc" id="L888">    }</span>

    /**
     * Generate an unquoted attribute -- size=1.
     * @param attributes The list so far.
     * @param bookmarks The array of positions.
     */
    private void naked (Vector attributes, int[] bookmarks)
    {
<span class="fc" id="L897">        attributes.addElement (new PageAttribute (</span>
<span class="fc" id="L898">            mPage, bookmarks[1], bookmarks[2], bookmarks[3],</span>
<span class="fc" id="L899">            bookmarks[4], (char)0));</span>
<span class="fc" id="L900">    }</span>

    /**
     * Generate an single quoted attribute -- width='100%'.
     * @param attributes The list so far.
     * @param bookmarks The array of positions.
     */
    private void single_quote (Vector attributes, int[] bookmarks)
    {
<span class="fc" id="L909">        attributes.addElement (new PageAttribute (</span>
<span class="fc" id="L910">            mPage, bookmarks[1], bookmarks[2], bookmarks[4] + 1,</span>
<span class="fc" id="L911">            bookmarks[5], '\''));</span>
<span class="fc" id="L912">    }</span>

    /**
     * Generate an double quoted attribute -- CONTENT=&quot;Test Development&quot;.
     * @param attributes The list so far.
     * @param bookmarks The array of positions.
     */
    private void double_quote (Vector attributes, int[] bookmarks)
    {
<span class="fc" id="L921">        attributes.addElement (new PageAttribute (</span>
<span class="fc" id="L922">            mPage, bookmarks[1], bookmarks[2], bookmarks[5] + 1,</span>
<span class="fc" id="L923">            bookmarks[6], '&quot;'));</span>
<span class="fc" id="L924">    }</span>

    /**
     * Parse a tag.
     * Parse the name and attributes from a start tag.&lt;p&gt;
     * From the &lt;a href=&quot;http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2&quot;&gt;
     * HTML 4.01 Specification, W3C Recommendation 24 December 1999&lt;/a&gt;
     * http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2&lt;p&gt;
     * &lt;cite&gt;
     * 3.2.2 Attributes&lt;p&gt;
     * Elements may have associated properties, called attributes, which may
     * have values (by default, or set by authors or scripts). Attribute/value
     * pairs appear before the final &quot;&gt;&quot; of an element's start tag. Any number
     * of (legal) attribute value pairs, separated by spaces, may appear in an
     * element's start tag. They may appear in any order.&lt;p&gt;
     * In this example, the id attribute is set for an H1 element:
     * &lt;code&gt;
     * &amp;lt;H1 id=&quot;section1&quot;&amp;gt;
     * &lt;/code&gt;
     * This is an identified heading thanks to the id attribute
     * &lt;code&gt;
     * &amp;lt;/H1&amp;gt;
     * &lt;/code&gt;
     * By default, SGML requires that all attribute values be delimited using
     * either double quotation marks (ASCII decimal 34) or single quotation
     * marks (ASCII decimal 39). Single quote marks can be included within the
     * attribute value when the value is delimited by double quote marks, and
     * vice versa. Authors may also use numeric character references to
     * represent double quotes (&amp;amp;#34;) and single quotes (&amp;amp;#39;).
     * For doublequotes authors can also use the character entity reference
     * &amp;amp;quot;.&lt;p&gt;
     * In certain cases, authors may specify the value of an attribute without
     * any quotation marks. The attribute value may only contain letters
     * (a-z and A-Z), digits (0-9), hyphens (ASCII decimal 45),
     * periods (ASCII decimal 46), underscores (ASCII decimal 95),
     * and colons (ASCII decimal 58). We recommend using quotation marks even
     * when it is possible to eliminate them.&lt;p&gt;
     * Attribute names are always case-insensitive.&lt;p&gt;
     * Attribute values are generally case-insensitive. The definition of each
     * attribute in the reference manual indicates whether its value is
     * case-insensitive.&lt;p&gt;
     * All the attributes defined by this specification are listed in the
     * attribute index.&lt;p&gt;
     * &lt;/cite&gt;
     * &lt;p&gt;
     * This method uses a state machine with the following states:
     * &lt;ol&gt;
     * &lt;li&gt;state 0 - outside of any attribute&lt;/li&gt;
     * &lt;li&gt;state 1 - within attributre name&lt;/li&gt;
     * &lt;li&gt;state 2 - equals hit&lt;/li&gt;
     * &lt;li&gt;state 3 - within naked attribute value.&lt;/li&gt;
     * &lt;li&gt;state 4 - within single quoted attribute value&lt;/li&gt;
     * &lt;li&gt;state 5 - within double quoted attribute value&lt;/li&gt;
     * &lt;li&gt;state 6 - whitespaces after attribute name could lead to state 2 (=)or state 0&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * The starting point for the various components is stored in an array
     * of integers that match the initiation point for the states one-for-one,
     * i.e. bookmarks[0] is where state 0 began, bookmarks[1] is where state 1
     * began, etc.
     * Attributes are stored in a &lt;code&gt;Vector&lt;/code&gt; having
     * one slot for each whitespace or attribute/value pair.
     * The first slot is for attribute name (kind of like a standalone attribute).
     * @param start The position at which to start scanning.
     * @return The parsed tag.
     * @exception ParserException If a problem occurs reading from the source.
     */
    protected Node parseTag (int start)
        throws
            ParserException
    {
        boolean done;
        char ch;
        int state;
        int[] bookmarks;
        Vector attributes;

<span class="fc" id="L1001">        done = false;</span>
<span class="fc" id="L1002">        attributes = new Vector ();</span>
<span class="fc" id="L1003">        state = 0;</span>
<span class="fc" id="L1004">        bookmarks = new int[8];</span>
<span class="fc" id="L1005">        bookmarks[0] = mCursor.getPosition ();</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        while (!done)</span>
        {
<span class="fc" id="L1008">            bookmarks[state + 1] = mCursor.getPosition ();</span>
<span class="fc" id="L1009">            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L1010" title="1 of 8 branches missed.">            switch (state)</span>
            {
                case 0: // outside of any attribute
<span class="fc bfc" id="L1013" title="All 6 branches covered.">                    if ((Page.EOF == ch) || ('&gt;' == ch) || ('&lt;' == ch))</span>
                    {
<span class="fc bfc" id="L1015" title="All 2 branches covered.">                        if ('&lt;' == ch)</span>
                        {
                            // don't consume the opening angle
<span class="fc" id="L1018">                            mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L1019">                            bookmarks[state + 1] = mCursor.getPosition ();</span>
                        }
<span class="fc" id="L1021">                        whitespace (attributes, bookmarks);</span>
<span class="fc" id="L1022">                        done = true;</span>
<span class="fc" id="L1023">                    }</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">                    else if (!Character.isWhitespace (ch))</span>
                    {
<span class="fc" id="L1026">                        whitespace (attributes, bookmarks);</span>
<span class="fc" id="L1027">                        state = 1;</span>
                    }
<span class="fc" id="L1029">                    break;</span>
                case 1: // within attribute name
<span class="pc bpc" id="L1031" title="1 of 6 branches missed.">                    if ((Page.EOF == ch) || ('&gt;' == ch) || ('&lt;' == ch))</span>
                    {
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">                        if ('&lt;' == ch)</span>
                        {
                            // don't consume the opening angle
<span class="nc" id="L1036">                            mPage.ungetCharacter (mCursor);</span>
<span class="nc" id="L1037">                            bookmarks[state + 1] = mCursor.getPosition ();</span>
                        }
<span class="fc" id="L1039">                        standalone (attributes, bookmarks);</span>
<span class="fc" id="L1040">                        done = true;</span>
<span class="fc" id="L1041">                    }</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">                    else if (Character.isWhitespace (ch))</span>
                    {
                        // whitespaces might be followed by next attribute or an equal sign
                        // see Bug #891058 Bug in lexer.
<span class="fc" id="L1046">                        bookmarks[6] = bookmarks[2]; // setting the bookmark[0] is done in state 6 if applicable</span>
<span class="fc" id="L1047">                        state = 6;</span>
<span class="fc" id="L1048">                    }</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">                    else if ('=' == ch)</span>
<span class="fc" id="L1050">                        state = 2;</span>
<span class="fc" id="L1051">                    break;</span>
                case 2: // equals hit
<span class="pc bpc" id="L1053" title="1 of 4 branches missed.">                    if ((Page.EOF == ch) || ('&gt;' == ch))</span>
                    {
<span class="fc" id="L1055">                        empty (attributes, bookmarks);</span>
<span class="fc" id="L1056">                        done = true;</span>
<span class="fc" id="L1057">                    }</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">                    else if ('\'' == ch)</span>
                    {
<span class="fc" id="L1060">                        state = 4;</span>
<span class="fc" id="L1061">                        bookmarks[4] = bookmarks[3];</span>
<span class="fc" id="L1062">                    }</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">                    else if ('&quot;' == ch)</span>
                    {
<span class="fc" id="L1065">                        state = 5;</span>
<span class="fc" id="L1066">                        bookmarks[5] = bookmarks[3];</span>
<span class="fc" id="L1067">                    }</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">                    else if (Character.isWhitespace (ch))</span>
                    { 
                        // collect white spaces after &quot;=&quot; into the assignment string;
                        // do nothing
                        // see Bug #891058 Bug in lexer.
                    }
                    else
<span class="fc" id="L1075">                        state = 3;</span>
<span class="fc" id="L1076">                    break;</span>
                case 3: // within naked attribute value
<span class="pc bpc" id="L1078" title="1 of 4 branches missed.">                    if ((Page.EOF == ch) || ('&gt;' == ch))</span>
                    {
<span class="fc" id="L1080">                        naked (attributes, bookmarks);</span>
<span class="fc" id="L1081">                        done = true;</span>
<span class="fc" id="L1082">                    }</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                    else if (Character.isWhitespace (ch))</span>
                    {
<span class="fc" id="L1085">                        naked (attributes, bookmarks);</span>
<span class="fc" id="L1086">                        bookmarks[0] = bookmarks[4];</span>
<span class="fc" id="L1087">                        state = 0;</span>
                    }
<span class="fc" id="L1089">                    break;</span>
                case 4: // within single quoted attribute value
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">                    if (Page.EOF == ch)</span>
                    {
<span class="nc" id="L1093">                        single_quote (attributes, bookmarks);</span>
<span class="nc" id="L1094">                        done = true; // complain?</span>
<span class="nc" id="L1095">                    }</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">                    else if ('\'' == ch)</span>
                    {
<span class="fc" id="L1098">                        single_quote (attributes, bookmarks);</span>
<span class="fc" id="L1099">                        bookmarks[0] = bookmarks[5] + 1;</span>
<span class="fc" id="L1100">                        state = 0;</span>
                    }
<span class="fc" id="L1102">                    break;</span>
                case 5: // within double quoted attribute value
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">                    if (Page.EOF == ch)</span>
                    {
<span class="nc" id="L1106">                        double_quote (attributes, bookmarks);</span>
<span class="nc" id="L1107">                        done = true; // complain?</span>
<span class="nc" id="L1108">                    }</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">                    else if ('&quot;' == ch)</span>
                    {
<span class="fc" id="L1111">                        double_quote (attributes, bookmarks);</span>
<span class="fc" id="L1112">                        bookmarks[0] = bookmarks[6] + 1;</span>
<span class="fc" id="L1113">                        state = 0;</span>
                    }
<span class="fc" id="L1115">                    break;</span>
                // patch for lexer state correction by
                // Gernot Fricke
                // See Bug # 891058 Bug in lexer.
                case 6: // undecided for state 0 or 2
                        // we have read white spaces after an attributte name
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">                    if (Page.EOF == ch)</span>
                    {
                        // same as last else clause
<span class="nc" id="L1124">                        standalone (attributes, bookmarks);</span>
<span class="nc" id="L1125">                  	    bookmarks[0]=bookmarks[6];</span>
<span class="nc" id="L1126">                  	    mPage.ungetCharacter (mCursor);</span>
<span class="nc" id="L1127">                  	    state=0;</span>
<span class="nc" id="L1128">                    }</span>
<span class="fc bfc" id="L1129" title="All 2 branches covered.">                    else if (Character.isWhitespace (ch))</span>
                    { 
                        // proceed
                    } 
<span class="fc bfc" id="L1133" title="All 2 branches covered.">                    else if ('=' == ch) // yepp. the white spaces belonged to the equal.</span>
                    {
<span class="fc" id="L1135">                        bookmarks[2] = bookmarks[6];</span>
<span class="fc" id="L1136">                        bookmarks[3] = bookmarks[7];</span>
<span class="fc" id="L1137">                        state=2;</span>
<span class="fc" id="L1138">                    }</span>
                    else
                    {
                        // white spaces were not ended by equal
                        // meaning the attribute was a stand alone attribute
                        // now: create the stand alone attribute and rewind 
                        // the cursor to the end of the white spaces
                        // and restart scanning as whitespace attribute.
<span class="fc" id="L1146">                  	    standalone (attributes, bookmarks);</span>
<span class="fc" id="L1147">                  	    bookmarks[0]=bookmarks[6];</span>
<span class="fc" id="L1148">                  	    mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L1149">                  	    state=0;</span>
                   	}
<span class="fc" id="L1151">                    break;</span>
                default:
<span class="nc" id="L1153">                    throw new IllegalStateException (&quot;how the fuck did we get in state &quot; + state);</span>
            }
        }

<span class="fc" id="L1157">        return (makeTag (start, mCursor.getPosition (), attributes));</span>
    }

    /**
     * Create a tag node based on the current cursor and the one provided.
     * @param start The starting point of the node.
     * @param end The ending point of the node.
     * @param attributes The attributes parsed from the tag.
     * @exception ParserException If the nodefactory creation of the tag node fails.
     * @return The new Tag node.
     */
    protected Node makeTag (int start, int end, Vector attributes)
        throws
            ParserException
    {
        int length;
        Node ret;

<span class="fc" id="L1175">        length = end - start;</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">        if (0 != length)</span>
        {   // return tag based on second character, '/', '%', Letter (ch), '!'
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">            if (2 &gt; length)</span>
                // this is an error
<span class="nc" id="L1180">                return (makeString (start, end));</span>
<span class="fc" id="L1181">            ret = getNodeFactory ().createTagNode (this.getPage (), start, end, attributes);</span>
<span class="fc" id="L1182">        }</span>
        else
<span class="nc" id="L1184">            ret = null;</span>

<span class="fc" id="L1186">        return (ret);</span>
    }

    /**
     * Parse a comment.
     * Parse a remark markup.&lt;p&gt;
     * From the &lt;a href=&quot;http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4&quot;&gt;
     * HTML 4.01 Specification, W3C Recommendation 24 December 1999&lt;/a&gt;
     * http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4&lt;p&gt;
     * &lt;cite&gt;
     * 3.2.4 Comments&lt;p&gt;
     * HTML comments have the following syntax:&lt;p&gt;
     * &lt;code&gt;
     * &amp;lt;!-- this is a comment --&amp;gt;&lt;p&gt;
     * &amp;lt;!-- and so is this one,&lt;p&gt;
     *     which occupies more than one line --&amp;gt;&lt;p&gt;
     * &lt;/code&gt;
     * White space is not permitted between the markup declaration
     * open delimiter(&quot;&amp;lt;!&quot;) and the comment open delimiter (&quot;--&quot;),
     * but is permitted between the comment close delimiter (&quot;--&quot;) and
     * the markup declaration close delimiter (&quot;&amp;gt;&quot;).
     * A common error is to include a string of hyphens (&quot;---&quot;) within a comment.
     * Authors should avoid putting two or more adjacent hyphens inside comments.
     * Information that appears between comments has no special meaning
     * (e.g., character references are not interpreted as such).
     * Note that comments are markup.&lt;p&gt;
     * &lt;/cite&gt;
     * &lt;p&gt;
     * This method uses a state machine with the following states:
     * &lt;ol&gt;
     * &lt;li&gt;state 0 - prior to the first open delimiter (first dash)&lt;/li&gt;
     * &lt;li&gt;state 1 - prior to the second open delimiter (second dash)&lt;/li&gt;
     * &lt;li&gt;state 2 - prior to the first closing delimiter (first dash)&lt;/li&gt;
     * &lt;li&gt;state 3 - prior to the second closing delimiter (second dash)&lt;/li&gt;
     * &lt;li&gt;state 4 - prior to the terminating &amp;gt;&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * All comment text (everything excluding the &amp;lt; and &amp;gt;), is included
     * in the remark text.
     * We allow terminators like --!&amp;gt; even though this isn't part of the spec.
     * @param start The position at which to start scanning.
     * @param quotesmart If &lt;code&gt;true&lt;/code&gt;, strings ignore quoted contents.
     * @return The parsed node.
     * @exception ParserException If a problem occurs reading from the source.
     */
    protected Node parseRemark (int start, boolean quotesmart)
        throws
            ParserException
    {
        boolean done;
        char ch;
        int state;

<span class="fc" id="L1239">        done = false;</span>
<span class="fc" id="L1240">        state = 0;</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        while (!done)</span>
        {
<span class="fc" id="L1243">            ch = mPage.getCharacter (mCursor);</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">            if (Page.EOF == ch)</span>
<span class="fc" id="L1245">                done = true;</span>
            else
<span class="pc bpc" id="L1247" title="1 of 6 branches missed.">                switch (state)</span>
                {
                    case 0: // prior to the first open delimiter
<span class="pc bpc" id="L1250" title="1 of 2 branches missed.">                        if ('&gt;' == ch)</span>
<span class="nc" id="L1251">                            done = true;</span>
<span class="pc bpc" id="L1252" title="1 of 2 branches missed.">                        if ('-' == ch)</span>
<span class="fc" id="L1253">                            state = 1;</span>
                        else
<span class="nc" id="L1255">                            return (parseString (start, quotesmart));</span>
                        break;
                    case 1: // prior to the second open delimiter
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">                        if ('-' == ch)</span>
                        {
                            // handle &lt;!--&gt; because netscape does
<span class="fc" id="L1261">                            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">                            if (Page.EOF == ch)</span>
<span class="nc" id="L1263">                                done = true;</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">                            else if ('&gt;' == ch)</span>
<span class="fc" id="L1265">                                done = true;</span>
                            else
                            {
<span class="fc" id="L1268">                                mPage.ungetCharacter (mCursor);</span>
<span class="fc" id="L1269">                                state = 2;</span>
                            }                        
<span class="fc" id="L1271">                        }</span>
                        else
<span class="nc" id="L1273">                            return (parseString (start, quotesmart));</span>
                        break;
                    case 2: // prior to the first closing delimiter
<span class="fc bfc" id="L1276" title="All 2 branches covered.">                        if ('-' == ch)</span>
<span class="fc" id="L1277">                            state = 3;</span>
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">                        else if (Page.EOF == ch)</span>
<span class="nc" id="L1279">                            return (parseString (start, quotesmart)); // no terminator</span>
                        break;
                    case 3: // prior to the second closing delimiter
<span class="fc bfc" id="L1282" title="All 2 branches covered.">                        if ('-' == ch)</span>
<span class="fc" id="L1283">                            state = 4;</span>
                        else
<span class="fc" id="L1285">                            state = 2;</span>
<span class="fc" id="L1286">                        break;</span>
                    case 4: // prior to the terminating &gt;
<span class="fc bfc" id="L1288" title="All 2 branches covered.">                        if ('&gt;' == ch)</span>
<span class="fc" id="L1289">                            done = true;</span>
<span class="fc bfc" id="L1290" title="All 2 branches covered.">                        else if (Character.isWhitespace (ch))</span>
                        {
                            // stay in state 4
                        }
                        else
<span class="pc bpc" id="L1295" title="2 of 6 branches missed.">                            if (!STRICT_REMARKS &amp;&amp; (('-' == ch) || ('!' == ch)))</span>
                            {
                                // stay in state 4
                            }
                            else
                                // bug #1345049 HTMLParser should not terminate a comment with ---&gt;
                                // should maybe issue a warning mentioning STRICT_REMARKS
<span class="fc" id="L1302">                                state = 2;</span>
<span class="fc" id="L1303">                        break;</span>
                    default:
<span class="nc" id="L1305">                        throw new IllegalStateException (&quot;how the fuck did we get in state &quot; + state);</span>
                }
        }

<span class="fc" id="L1309">        return (makeRemark (start, mCursor.getPosition ()));</span>
    }

    /**
     * Create a remark node based on the current cursor and the one provided.
     * @param start The starting point of the node.
     * @param end The ending point of the node.
     * @exception ParserException If the nodefactory creation of the remark node fails.
     * @return The new Remark node.
     */
    protected Node makeRemark (int start, int end)
        throws
            ParserException
    {
        int length;
        Node ret;

<span class="fc" id="L1326">        length = end - start;</span>
<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">        if (0 != length)</span>
        {   // return tag based on second character, '/', '%', Letter (ch), '!'
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">            if (2 &gt; length)</span>
                // this is an error
<span class="nc" id="L1331">                return (makeString (start, end));</span>
<span class="fc" id="L1332">            ret = getNodeFactory ().createRemarkNode (this.getPage (), start, end);</span>
<span class="fc" id="L1333">        }</span>
        else
<span class="nc" id="L1335">            ret = null;</span>
        
<span class="fc" id="L1337">        return (ret);</span>
    }

    /**
     * Parse a java server page node.
     * Scan characters until &quot;%&amp;gt;&quot; is encountered, or the input stream is
     * exhausted, in which case &lt;code&gt;null&lt;/code&gt; is returned.
     * @param start The position at which to start scanning.
     * @return The parsed node.
     * @exception ParserException If a problem occurs reading from the source.
     */
    protected Node parseJsp (int start)
        throws
            ParserException
    {
        boolean done;
        char ch;
        int state;
        Vector attributes;
        int code;

<span class="fc" id="L1358">        done = false;</span>
<span class="fc" id="L1359">        state = 0;</span>
<span class="fc" id="L1360">        code = 0;</span>
<span class="fc" id="L1361">        attributes = new Vector ();</span>
        // &lt;%xyz%&gt;
        // 012223d
        // &lt;%=xyz%&gt;
        // 0122223d
        // &lt;%@xyz%d
        // 0122223d
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        while (!done)</span>
        {
<span class="fc" id="L1370">            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L1371" title="1 of 7 branches missed.">            switch (state)</span>
            {
                case 0: // prior to the percent
<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">                    switch (ch)</span>
                    {
                        case '%': // &lt;%
<span class="fc" id="L1377">                            state = 1;</span>
<span class="fc" id="L1378">                            break;</span>
                        // case Page.EOF: // &lt;\0
                        // case '&gt;': // &lt;&gt;
                        default:
<span class="nc" id="L1382">                            done = true;</span>
                            break;
                    }
<span class="nc" id="L1385">                    break;</span>
                case 1: // prior to the optional qualifier
<span class="pc bpc" id="L1387" title="1 of 3 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF:   // &lt;%\0
                        case '&gt;': // &lt;%&gt;
<span class="nc" id="L1391">                            done = true;</span>
<span class="nc" id="L1392">                            break;</span>
                        case '=': // &lt;%=
                        case '@': // &lt;%@
<span class="fc" id="L1395">                            code = mCursor.getPosition ();</span>
<span class="fc" id="L1396">                            attributes.addElement (new PageAttribute (mPage, start + 1, code, -1, -1, (char)0));</span>
<span class="fc" id="L1397">                            state = 2;</span>
<span class="fc" id="L1398">                            break;</span>
                        default:  // &lt;%x
<span class="fc" id="L1400">                            code = mCursor.getPosition () - 1;</span>
<span class="fc" id="L1401">                            attributes.addElement (new PageAttribute (mPage, start + 1, code, -1, -1, (char)0));</span>
<span class="fc" id="L1402">                            state = 2;</span>
                            break;
                    }
<span class="fc" id="L1405">                    break;</span>
                case 2: // prior to the closing percent
<span class="pc bpc" id="L1407" title="1 of 5 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;%x\0
                        case '&gt;': // &lt;%x&gt;
<span class="nc" id="L1411">                            done = true;</span>
<span class="nc" id="L1412">                            break;</span>
                        case '\'':
                        case '&quot;':// &lt;%???&quot;
<span class="fc" id="L1415">                            state = ch;</span>
<span class="fc" id="L1416">                            break;</span>
                        case '%': // &lt;%???%
<span class="fc" id="L1418">                            state = 3;</span>
<span class="fc" id="L1419">                            break;</span>
                        case '/': // // or /*
<span class="fc" id="L1421">                            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L1422" title="1 of 2 branches missed.">                            if (ch == '/') </span>
                            {   // find the \n or \r
                                while(true)
                                {
<span class="fc" id="L1426">                                    ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">                                    if (ch == Page.EOF)</span>
                                    {
<span class="nc" id="L1429">                                        done = true;</span>
<span class="nc" id="L1430">                                        break;</span>
                                    }
<span class="pc bpc" id="L1432" title="1 of 4 branches missed.">                                    else if (ch == '\n' || ch == '\r')</span>
                                    {
                                        break;
                                    }
                                }
<span class="nc" id="L1437">                            }</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">                            else if (ch == '*')</span>
                            {
                                do
                                {
                                    do
<span class="nc" id="L1443">                                        ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L1444" title="All 4 branches missed.">                                    while ((Page.EOF != ch) &amp;&amp; ('*' != ch));</span>
<span class="nc" id="L1445">                                    ch = mPage.getCharacter (mCursor);</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">                                    if (ch == '*')</span>
<span class="nc" id="L1447">                                        mPage.ungetCharacter (mCursor);</span>
                                }
<span class="nc bnc" id="L1449" title="All 4 branches missed.">                                while ((Page.EOF != ch) &amp;&amp; ('/' != ch));</span>
<span class="nc" id="L1450">                            }</span>
                            else
<span class="nc" id="L1452">                                mPage.ungetCharacter (mCursor);</span>
<span class="nc" id="L1453">                            break;</span>
                        default:  // &lt;%???x
                            break;
                    }
<span class="fc" id="L1457">                    break;</span>
                case 3:
<span class="pc bpc" id="L1459" title="2 of 3 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;%x??%\0
<span class="nc" id="L1462">                            done = true;</span>
<span class="nc" id="L1463">                            break;</span>
                        case '&gt;':
<span class="fc" id="L1465">                            state = 4;</span>
<span class="fc" id="L1466">                            done = true;</span>
<span class="fc" id="L1467">                            break;</span>
                        default:  // &lt;%???%x
<span class="nc" id="L1469">                            state = 2;</span>
                            break;
                    }
<span class="nc" id="L1472">                    break;</span>
                case '&quot;':
<span class="pc bpc" id="L1474" title="1 of 3 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;%x??&quot;\0
<span class="nc" id="L1477">                            done = true;</span>
<span class="nc" id="L1478">                            break;</span>
                        case '&quot;':
<span class="fc" id="L1480">                            state = 2;</span>
<span class="fc" id="L1481">                            break;</span>
                        default:  // &lt;%???'??x
                            break;
                    }
<span class="fc" id="L1485">                    break;</span>
                case '\'':
<span class="pc bpc" id="L1487" title="1 of 3 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;%x??'\0
<span class="nc" id="L1490">                            done = true;</span>
<span class="nc" id="L1491">                            break;</span>
                        case '\'':
<span class="fc" id="L1493">                            state = 2;</span>
<span class="fc" id="L1494">                            break;</span>
                        default:  // &lt;%???&quot;??x
                            break;
                    }
<span class="fc" id="L1498">                    break;</span>
                default:
<span class="nc" id="L1500">                    throw new IllegalStateException (&quot;how the fuck did we get in state &quot; + state);</span>
            }
        }

<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">        if (4 == state) // normal exit</span>
        {
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">            if (0 != code)</span>
            {
<span class="fc" id="L1508">                state = mCursor.getPosition () - 2; // reuse state</span>
<span class="fc" id="L1509">                attributes.addElement (new PageAttribute (mPage, code, state, -1, -1, (char)0));</span>
<span class="fc" id="L1510">                attributes.addElement (new PageAttribute (mPage, state, state + 1, -1, -1, (char)0));</span>
<span class="fc" id="L1511">            }</span>
            else
<span class="nc" id="L1513">                throw new IllegalStateException (&quot;jsp with no code!&quot;);</span>
        }
        else
<span class="nc" id="L1516">            return (parseString (start, true)); // hmmm, true?</span>

<span class="fc" id="L1518">        return (makeTag (start, mCursor.getPosition (), attributes));</span>
    }

    /**
     * Parse an XML processing instruction.
     * Scan characters until &quot;?&amp;gt;&quot; is encountered, or the input stream is
     * exhausted, in which case &lt;code&gt;null&lt;/code&gt; is returned.
     * @param start The position at which to start scanning.
     * @return The parsed node.
     * @exception ParserException If a problem occurs reading from the source.
     */
    protected Node parsePI (int start)
        throws
            ParserException
    {
        boolean done;
        char ch;
        int state;
        Vector attributes;
        int code;

<span class="fc" id="L1539">        done = false;</span>
<span class="fc" id="L1540">        state = 0;</span>
<span class="fc" id="L1541">        code = 0;</span>
<span class="fc" id="L1542">        attributes = new Vector ();</span>
        // &lt;?xyz?&gt;
        // 011112d
<span class="fc bfc" id="L1545" title="All 2 branches covered.">        while (!done)</span>
        {
<span class="fc" id="L1547">            ch = mPage.getCharacter (mCursor);</span>
<span class="pc bpc" id="L1548" title="2 of 6 branches missed.">            switch (state)</span>
            {
                case 0: // prior to the question mark
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">                    switch (ch)</span>
                    {
                        case '?': // &lt;?
<span class="fc" id="L1554">                            code = mCursor.getPosition ();</span>
<span class="fc" id="L1555">                            attributes.addElement (new PageAttribute (mPage, start + 1, code, -1, -1, (char)0));</span>
<span class="fc" id="L1556">                            state = 1;</span>
<span class="fc" id="L1557">                            break;</span>
                        // case Page.EOF: // &lt;\0
                        // case '&gt;': // &lt;&gt;
                        default:
<span class="nc" id="L1561">                            done = true;</span>
                            break;
                    }
<span class="nc" id="L1564">                    break;</span>
                case 1: // prior to the closing question mark
<span class="pc bpc" id="L1566" title="1 of 4 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;?x\0
                        case '&gt;': // &lt;?x&gt;
<span class="nc" id="L1570">                            done = true;</span>
<span class="nc" id="L1571">                            break;</span>
                        case '\'':
                        case '&quot;':// &lt;?...&quot;
<span class="fc" id="L1574">                            state = ch;</span>
<span class="fc" id="L1575">                            break;</span>
                        case '?': // &lt;?...?
<span class="fc" id="L1577">                            state = 2;</span>
<span class="fc" id="L1578">                            break;</span>
                        default:  // &lt;?...x
                            break;
                    }
<span class="fc" id="L1582">                    break;</span>
                case 2:
<span class="pc bpc" id="L1584" title="2 of 3 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;?x..?\0
<span class="nc" id="L1587">                            done = true;</span>
<span class="nc" id="L1588">                            break;</span>
                        case '&gt;':
<span class="fc" id="L1590">                            state = 3;</span>
<span class="fc" id="L1591">                            done = true;</span>
<span class="fc" id="L1592">                            break;</span>
                        default:  // &lt;?...?x
<span class="nc" id="L1594">                            state = 1;</span>
                            break;
                    }
<span class="nc" id="L1597">                    break;</span>
                case '&quot;':
<span class="pc bpc" id="L1599" title="1 of 3 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;?x..&quot;\0
<span class="nc" id="L1602">                            done = true;</span>
<span class="nc" id="L1603">                            break;</span>
                        case '&quot;':
<span class="fc" id="L1605">                            state = 1;</span>
<span class="fc" id="L1606">                            break;</span>
                        default:  // &lt;?...'.x
                            break;
                    }
<span class="fc" id="L1610">                    break;</span>
                case '\'':
<span class="nc bnc" id="L1612" title="All 3 branches missed.">                    switch (ch)</span>
                    {
                        case Page.EOF: // &lt;?x..'\0
<span class="nc" id="L1615">                            done = true;</span>
<span class="nc" id="L1616">                            break;</span>
                        case '\'':
<span class="nc" id="L1618">                            state = 1;</span>
<span class="nc" id="L1619">                            break;</span>
                        default:  // &lt;?...&quot;..x
                            break;
                    }
<span class="nc" id="L1623">                    break;</span>
                default:
<span class="nc" id="L1625">                    throw new IllegalStateException (&quot;how the fuck did we get in state &quot; + state);</span>
            }
        }

<span class="pc bpc" id="L1629" title="1 of 2 branches missed.">        if (3 == state) // normal exit</span>
        {
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">            if (0 != code)</span>
            {
<span class="fc" id="L1633">                state = mCursor.getPosition () - 2; // reuse state</span>
<span class="fc" id="L1634">                attributes.addElement (new PageAttribute (mPage, code, state, -1, -1, (char)0));</span>
<span class="fc" id="L1635">                attributes.addElement (new PageAttribute (mPage, state, state + 1, -1, -1, (char)0));</span>
<span class="fc" id="L1636">            }</span>
            else
<span class="nc" id="L1638">                throw new IllegalStateException (&quot;processing instruction with no content&quot;);</span>
        }
        else
<span class="nc" id="L1641">            return (parseString (start, true)); // hmmm, true?</span>

<span class="fc" id="L1643">        return (makeTag (start, mCursor.getPosition (), attributes));</span>
    }

    //
    // Main program
    //

    /**
     * Mainline for command line operation
     * @param args [0] The URL to parse.
     * @exception MalformedURLException If the provided URL cannot be resolved.
     * @exception ParserException If the parse fails.
     */
    public static void main (String[] args)
        throws
            MalformedURLException,
            ParserException
    {
        ConnectionManager manager;
        Lexer lexer;
        Node node;

<span class="nc bnc" id="L1665" title="All 2 branches missed.">        if (0 &gt;= args.length)</span>
        {
<span class="nc" id="L1667">            System.out.println (&quot;HTML Lexer v&quot; + getVersion () + &quot;\n&quot;);</span>
<span class="nc" id="L1668">            System.out.println ();</span>
<span class="nc" id="L1669">            System.out.println (&quot;usage: java -jar htmllexer.jar &lt;url&gt;&quot;);</span>
<span class="nc" id="L1670">        }</span>
        else
        {
            try
            {
<span class="nc" id="L1675">                manager = Page.getConnectionManager ();</span>
<span class="nc" id="L1676">                lexer = new Lexer (manager.openConnection (args[0]));</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">                while (null != (node = lexer.nextNode (false)))</span>
<span class="nc" id="L1678">                    System.out.println (node.toString ());</span>
<span class="nc" id="L1679">            }</span>
<span class="nc" id="L1680">            catch (ParserException pe)</span>
            {
<span class="nc" id="L1682">                System.out.println (pe.getMessage ());</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">                if (null != pe.getThrowable ())</span>
<span class="nc" id="L1684">                    System.out.println (pe.getThrowable ().getMessage ());</span>
            }
        }
<span class="nc" id="L1687">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (4) (Oct 27, 2015 3:17:09 PM)</div></body></html>